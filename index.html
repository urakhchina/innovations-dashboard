<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 New Product Launch Analytics Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .dashboard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .dashboard-header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 50%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            font-weight: 800;
            color: #fff;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }
        .badge-red   { background: rgba(220, 38, 38, 0.18); color: #fecaca; padding: 2px 6px; border-radius: 8px; }
        .badge-amber { background: rgba(245, 158, 11, 0.18); color: #fde68a; padding: 2px 6px; border-radius: 8px; }
        .badge-green { background: rgba(16, 185, 129, 0.18); color: #a7f3d0; padding: 2px 6px; border-radius: 8px; }
        .badge-gray  { background: rgba(156, 163, 175, 0.18); color: #d1d5db; padding: 2px 6px; border-radius: 8px; }

        
        .dashboard-header .subtitle {
            font-size: 1.2em;
            color: rgba(255,255,255,0.9);
            position: relative;
            z-index: 1;
        }
        
        .new-products-banner {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(240,147,251,0.3);
        }
        
        .new-products-banner h2 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.8em;
        }
        
        .product-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .product-pill {
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 25px;
            color: #fff;
            font-weight: 600;
            font-size: 0.9em;
            border: 1px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }
        
        .product-pill:hover {
            transform: translateY(-2px);
            background: rgba(255,255,255,0.3);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .product-pill .quarter {
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
            font-size: 0.85em;
        }
        
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .kpi-card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }
        
        .kpi-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102,126,234,0.3);
            background: rgba(255,255,255,0.08);
        }
        
        .kpi-card .label {
            font-size: 0.9em;
            color: #a0a0a0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .kpi-card .value {
            font-size: 2em;
            font-weight: 700;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .kpi-card .change {
            font-size: 0.9em;
            color: #4ade80;
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .chart-container:hover {
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.08);
        }
        
        .chart-container h3 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chart-container canvas {
            max-height: 300px;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .table-container {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 30px;
            overflow-x: auto;
        }
        
        .table-container h3 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: rgba(102,126,234,0.2);
        }
        
        th {
            padding: 12px;
            text-align: left;
            color: #fff;
            font-weight: 600;
            border-bottom: 2px solid rgba(102,126,234,0.5);
        }
        
        td {
            padding: 10px 12px;
            color: #e0e0e0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        tbody tr:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .heatmap-container {
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .insights-section {
            background: linear-gradient(135deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 30px;
        }
        
        .insights-section h3 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .insight-item {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }
        
        .insight-item strong {
            color: #667eea;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102,126,234,0.3);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .tab-navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 12px 24px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .tab-button:hover {
            background: rgba(102,126,234,0.2);
            transform: translateY(-2px);
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            border-color: transparent;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="dashboard-header">
        <h1>üöÄ 2025 New Product Launch Analytics Dashboard</h1>
        <div class="subtitle">Executive Performance Metrics & Advanced Analytics</div>
    </div>
    
    <div class="new-products-banner">
        <h2>üì¶ New Product Launches</h2>
        <div class="product-pills" id="productPills"></div>
    </div>
    
    <div class="kpi-grid" id="kpiGrid"></div>
    
    <div class="tab-navigation">
        <button class="tab-button active" onclick="switchTab(event, 'overview')">üìä Overview</button>
        <button class="tab-button" onclick="switchTab(event, 'temporal')">üìà Temporal Analysis</button>
        <button class="tab-button" onclick="switchTab(event, 'distributor')">üè¢ Distributor Analytics</button>
        <button class="tab-button" onclick="switchTab(event, 'salesrep')">üë§ Sales Rep Performance</button>
        <button class="tab-button" onclick="switchTab(event, 'accounts')">üõí Account Analytics</button>
        <button class="tab-button" onclick="switchTab(event, 'product')">üì¶ Product Deep Dive</button>
        <button class="tab-button" onclick="switchTab(event, 'advanced')">üìã Other</button>
    </div>
    
    <div id="overview" class="tab-content active">
        <div class="analytics-grid">
            <div class="chart-container">
                <h3>üí∞ Revenue by Product</h3>
                <canvas id="revenueByProduct"></canvas>
            </div>
            <div class="chart-container">
                <h3>üì¶ Units Sold by Product</h3>
                <canvas id="unitsByProduct"></canvas>
            </div>
            <div class="chart-container full-width">
                <h3>üìà Monthly Revenue Trend</h3>
                <canvas id="monthlyTrend"></canvas>
            </div>
        </div>
    </div>
    
    <div id="temporal" class="tab-content">
        <div class="analytics-grid">
          <div class="chart-container full-width">
            <h3>üìä Product Launch Curves (Revenue Since Launch)</h3>
            <canvas id="launchCurves"></canvas>
          </div>
          <div class="chart-container">
            <h3>üìà Cumulative YTD Growth (Revenue)</h3>
            <canvas id="cumulativeGrowth"></canvas>
          </div>
          <div class="chart-container">
            <h3>üóìÔ∏è Quarterly Performance (Revenue & Units)</h3>
            <canvas id="quarterlyPerformance"></canvas>
          </div>
          <div class="chart-container full-width">
            <h3>üöÄ Year-End Projection (YEP) by Product</h3>
            <canvas id="yearEndProjection"></canvas>
            <div id="yepPaceToPlan" style="margin-top:8px;font-size:0.9em;color:#a0a0a0;">
              <!-- Filled by JS: Pace to Plan per product (shows ‚Äú‚Äî‚Äù where plan missing) -->
            </div>
          </div>
        </div>
      
        <div class="chart-container full-width">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
            <h3>üìÜ Weekly Velocity: Doors / OPA / RPD</h3>
            <div>
              <label for="weeklyScope" style="margin-right:8px;">View:</label>
              <select id="weeklyScope">
                <option value="overall">Overall</option>
                <option value="distributor">By Distributor</option>
                <option value="rep">By Rep</option>
                <option value="product">By Product</option>
              </select>
            </div>
          </div>
          <div class="analytics-grid">
            <div class="chart-container"><canvas id="doorsPerWeek"></canvas></div>
            <div class="chart-container"><canvas id="opaPerWeek"></canvas></div>
            <div class="chart-container"><canvas id="rpdPerWeek"></canvas></div>
          </div>
          <div style="font-size:0.85em;color:#a0a0a0;margin-top:6px;">
            Acceptance check: Sum of weekly paid invoices equals YTD paid invoices in current scope.
          </div>
          <div id="weeklyNarrative" style="
          margin-top:10px;
          padding:12px 14px;
          border-radius:10px;
          background:rgba(255,255,255,0.04);
          color:#cfd6e4;
          line-height:1.4;
          font-size:0.95em;">
          <!-- Filled by JS -->
        </div>
        </div>
      </div>
      
      <div id="distributor" class="tab-content">
        <div class="table-container full-width">
          <h3>üè¢ Distributor Performance Matrix</h3>
          <div style="font-size: 0.9em; color: #a0a0a0; margin-bottom: 15px;">
            Note: All metrics are based on paid invoices (revenue > 0) to exclude free goods and returns.
          </div>
          <table id="distributorTable"></table>
        </div>
      </div>
      
      <div id="salesrep" class="tab-content">
        <div class="table-container full-width">
          <h3>üéØ Sales Rep Leaderboard</h3>
          <div style="font-size: 0.9em; color: #a0a0a0; margin-bottom: 15px;">
            Note: Revenue totals include chargebacks/returns deducted. Count metrics (invoices, accounts) based on paid orders only.
          </div>
          <table id="repLeaderboard"></table>
        </div>
      </div>
      
      <div id="accounts" class="tab-content">
        <div class="analytics-grid">
          <div class="chart-container full-width">
            <h3>üìä Pareto Analysis (80/20 Rule for Revenue by Account)</h3>
            <canvas id="paretoAnalysis"></canvas>
          </div>
        </div>
        <div class="table-container full-width">
          <h3>üíé Top 20 Account Penetration</h3>
          <table id="accountPenetrationTable"></table>
        </div>
        <div class="table-container full-width">
          <h3>üõí All Accounts Analysis</h3>
          <table id="allAccountsTable"></table>
        </div>
      </div>
      
      <div id="product" class="tab-content">
        <div class="product-selector-container" style="margin-bottom: 25px; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px;">
          <label for="productSelector" style="margin-right: 10px; font-weight: 600;">Select a Product to Analyze:</label>
          <select id="productSelector" style="padding: 8px; border-radius: 8px; min-width: 300px;"></select>
        </div>
      
        <div class="kpi-grid" id="productKpiGrid"></div>
      
        <div class="analytics-grid" id="productChartsGrid">
          <div class="chart-container">
            <h3>Top Distributors by Revenue</h3>
            <canvas id="distributorMixForProductChart"></canvas>
          </div>
          <div class="table-container full-width">
            <h3>Account Performance for this Product</h3>
            <table id="accountsForProductTable"></table>
          </div>
        </div>
      </div> <!-- closes #product -->
      
      <div id="advanced" class="tab-content">
        <div class="insights-section">
          <h3>üéØ Advanced Analytics Insights</h3>
          <div id="advancedInsights"></div>
        </div>
        <div class="analytics-grid">
            <div class="chart-container">
              <h3>üó∫Ô∏è Product‚ÄìDistributor Heatmap</h3>
              <div id="heatmap" style="overflow-x: auto; overflow-y: hidden; max-width: 100%;"></div>
            </div>
            <div class="chart-container">
              <h3>üîÑ SKU Overlap Analysis</h3>
              <canvas id="skuOverlap"></canvas>
            </div>
          </div>

        <div id="aiReportBox" style="margin-top:12px;background:rgba(255,255,255,0.03);border-radius:10px;padding:16px;">
            <!-- Header -->
            <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin-bottom:12px;">
              <div style="font-weight:600;font-size:1.1em;">üìä Comprehensive Analytics Report</div>
              <div style="display:flex;gap:6px;">
                <button id="btnGenerateAIReport" style="padding:8px 14px;border-radius:8px;background:#667eea;color:white;border:none;cursor:pointer;font-weight:500;">Generate Report</button>
                <button id="btnCopyAIReport" style="padding:8px 14px;border-radius:8px;opacity:0.7;" disabled>üìã Copy</button>
                <button id="btnDownloadAIReport" style="padding:8px 14px;border-radius:8px;opacity:0.7;" disabled>‚¨á Download .md</button>
              </div>
            </div>

            <!-- Customization Options -->
            <div style="display:flex;gap:16px;margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;flex-wrap:wrap;">
              <div style="flex:1;min-width:200px;">
                <div style="font-size:0.85em;color:#a0a0a0;margin-bottom:4px;">Include Sections:</div>
                <div style="display:flex;flex-wrap:wrap;gap:8px;">
                  <label style="display:flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="checkbox" id="includeExecutive" checked style="cursor:pointer;">
                    <span style="font-size:0.9em;">Executive Summary</span>
                  </label>
                  <label style="display:flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="checkbox" id="includeChurn" checked style="cursor:pointer;">
                    <span style="font-size:0.9em;">Churn Risk</span>
                  </label>
                  <label style="display:flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="checkbox" id="includePerformers" checked style="cursor:pointer;">
                    <span style="font-size:0.9em;">Top/Bottom Performers</span>
                  </label>
                  <label style="display:flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="checkbox" id="includeFreeFill" checked style="cursor:pointer;">
                    <span style="font-size:0.9em;">Free Fill Analysis</span>
                  </label>
                </div>
              </div>
            </div>

            <!-- Output Area -->
            <textarea id="aiReportOutput" rows="16" style="width:100%;border-radius:8px;padding:12px;background:rgba(0,0,0,0.35);color:#cfd6e4;border:1px solid rgba(255,255,255,0.08);font-family:monospace;font-size:0.9em;line-height:1.5;" placeholder="Click 'Generate Report' to create a comprehensive markdown report with all dashboard insights..."></textarea>

            <!-- Preview Toggle -->
            <div style="margin-top:8px;display:flex;justify-content:space-between;align-items:center;">
              <div style="font-size:0.85em;color:#a0a0a0;">
                <span id="reportStats"></span>
              </div>
              <button id="btnPreviewReport" style="padding:6px 12px;border-radius:6px;font-size:0.85em;opacity:0.7;" disabled>üëÅ Preview HTML</button>
            </div>
          </div>

          <!-- Free Fill Reorder Analysis Section -->
          <div class="chart-container full-width">
            <h3>üéÅ Free Fill Reorder Analysis</h3>
            <canvas id="freeFillReorderChart"></canvas>
            <div id="freeFillStats" style="font-size:0.85em;color:#a0a0a0;margin-top:6px;"></div>
          </div>

          <!-- Free Fill Account Details Table -->
          <div class="table-container full-width">
            <h3>üßæ Free Fill Account Details</h3>
            <table id="freeFillAccountTable"></table>
          </div>

          <!-- Free Fill Reorder by SKU (YTD) -->
          <div class="table-container full-width">
            <h3>üîç Free Fill Reorder by SKU (YTD)</h3>
            <table id="freeFillBySkuTable"></table>
          </div>

          <!-- Free Fill Reorder by Sample Size (YTD) -->
          <div class="table-container full-width">
            <h3>üíµ Free Fill Reorder by Sample Size (YTD)</h3>
            <table id="freeFillByTypeTable"></table>
          </div>

          
      
        <div class="chart-container full-width">
          <h3>üß≤ Cohort Retention (First Purchase Month ‚Üí % with 2nd Order ‚â§30/60/90d)</h3>
          <canvas id="cohortRetention"></canvas>
          <div id="cohortNotes" style="font-size:0.9em;color:#a0a0a0;margin-top:6px;">
            Tooltips show numerator/denominator. Curves are monotonically non-increasing by construction.
          </div>
          <div id="cohortNarrative" style="
            margin-top:10px;
            padding:12px 14px;
            border-radius:10px;
            background:rgba(255,255,255,0.04);
            color:#cfd6e4;
            line-height:1.4;
            font-size:0.95em;">
            <!-- Filled by JS -->
        </div>
    </div>
    </div>
      
    
    <script>
        // Global data storage
        let dashboardData = {};
        let charts = {};
        const salesRepMap = {
            "-1": "-No Sales Employee-",
            "10": "Mariano Cruz",
            "12": "Andy Chasen",
            "2": "Christina Antrim",
            "22": "Steve Farzanfar",
            "24": "Mohit Kumar",
            "27": "Trina Hilley",
            "38": "Mid-West Territory",
            "59": "Shared Territory",
            "61": "BAD DEBT ACCOUNT",
            "62": "Bankruptcy",
            "63": "CLOS",
            "64": "COLLECTION ACCOUNT",
            "7": "Donald Corgill",
            "71": "Marshall McClean",
            "80": "iHerb",
            "81": "UNFI and WFM",
            "83": "Customer Care",
            "88": "Jenny Cooper",
            "9": "Lisa Clarke",
            "90": "Ashley Bolanos",
            "94": "Pamela Kehoe2",
            "95": "SPROUTS"
        };

        function parseAsLocalDate(ymdString) {
            // Parses a 'YYYY-MM-DD' string into a local Date object
            const [year, month] = ymdString.split('-').map(Number);
            // new Date(year, monthIndex, day) creates a local date.
            // month - 1 is needed because JavaScript months are 0-indexed (Jan=0).
            return new Date(year, month - 1, 1);
        }

        // --- Extra date helpers (day-accurate) ---
        function parseYMD(dateStr) {
        // Expects 'YYYY-MM-DD' string, but can also handle Date objects
        if (!dateStr) return null;
        if (dateStr instanceof Date) return dateStr;
        if (typeof dateStr !== 'string') return null;
        const [y,m,d] = dateStr.split('-').map(Number);
        return new Date(y, (m||1)-1, d||1);
        }
        const fmtWeek = d3.timeFormat('%Y-W%V'); // ISO week label

        // --- Paid invoice builder (reusable) ---
        function buildPaidInvoices(lines) {
        // Group by distributor, account, ship_to, date at invoice level
        const invoices = _.chain(lines)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(records => {
            const first = records[0];
            const revenue = _.sumBy(records, r => Number(r.revenue) || 0);
            const units = _.sumBy(records, r => Number(r.quantity ?? r.units) || 0);
            return {
                posting_date: parseYMD(first.posting_date), // keep date as Date
                distributor: first.distributor,
                sales_rep: first.sales_rep,
                canonical_code: first.canonical_code,
                product_name: first.product_name,
                upc_item_code_norm12: first.upc_item_code_norm12, // Add UPC for reliable filtering
                revenue,
                units
            };
            })
            .filter(inv => inv.revenue > 0) // "paid invoices" only
            .value();
        return invoices;
        }

        // ---------- AI Report Utilities ----------
        function asOfDateFromDetailed() {
            const maxDateStr = _.max(dashboardData.detailed.map(d => d.posting_date));
            return parseYMD(maxDateStr);
            }

            function buildWeeklyData(scope) {
            const paid = buildPaidInvoices(dashboardData.detailed);
            const keyGetter = scope === 'distributor' ? (inv => inv.distributor)
                            : scope === 'rep' ? (inv => (inv.sales_rep != null ? String(inv.sales_rep) : '-1'))
                            : (() => 'Overall');
            const fmt = d3.timeFormat('%Y-W%V');
            const grouped = _.groupBy(paid, inv => `${fmt(d3.timeWeek.floor(inv.posting_date))}::${String(keyGetter(inv))}`);
            const rows = _.map(grouped, (recs, k) => {
                const [week, key] = k.split('::');
                return { week, key,
                paidInvoices: recs.length,
                doors: calcDoors(recs),
                opa: calcOPA(recs),
                rpd: calcRPD(recs)
                };
            });
            const byKey = _.groupBy(rows, r => r.key);
            for (const k in byKey) byKey[k] = _.sortBy(byKey[k], r => r.week);
            const allWeeks = _.uniq(_.flatten(Object.values(byKey).map(arr => arr.map(r => r.week)))).sort();
            return { byKey, allWeeks };
            }

            function summarizeSeriesForReport(weeks, doors, opa, rpd) {
            const { summary, bullets } = summarizeSeries(weeks, doors, opa, rpd); // uses your enhanced function
            return { summary, bullets };
            }

            function extractYEPPlanRows() {
            // Rebuild quickly per your YEP table logic
            const byProduct = _.chain(dashboardData.detailed)
                .groupBy(d => d.product_name)
                .map((recs, name) => {
                const monthly = _.chain(recs).groupBy(r => r.posting_date.substring(0,7))
                    .map((rows, m) => ({ month:m, revenue: _.sumBy(rows, r => Number(r.revenue)||0) }))
                    .sortBy('month').value();
                const ytdActual = _.sumBy(monthly, 'revenue');
                const last3 = monthly.slice(-3);
                const avgRecent = _.meanBy(last3, 'revenue') || 0;
                const yePace = ytdActual + avgRecent * (12 - monthly.length);
                const fyPlan = fyPlanFor ? fyPlanFor('product', name) : null;
                const pace = (fyPlan && fyPlan > 0) ? (yePace / fyPlan) : null;
                return { product: name, fyPlan, yep: yePace, pace };
                })
                .sortBy(r => r.product)
                .value();
            return byProduct;
            }

            function buildCohortData() {
            const paid = buildPaidInvoices(dashboardData.detailed);
            const byAcctProd = _.groupBy(paid, inv => `${inv.canonical_code}::${inv.product_name}`);
            const firsts = [];
            for (const key in byAcctProd) {
                const arr = _.sortBy(byAcctProd[key], inv => inv.posting_date);
                const first = arr[0], second = arr[1] || null;
                firsts.push({
                cohortMonth: d3.timeFormat('%Y-%m')(d3.timeMonth.floor(first.posting_date)),
                has2nd30: !!(second && (second.posting_date - first.posting_date) <= 30*864e5),
                has2nd60: !!(second && (second.posting_date - first.posting_date) <= 60*864e5),
                has2nd90: !!(second && (second.posting_date - first.posting_date) <= 90*864e5)
                });
            }
            const byCohort = _.groupBy(firsts, r => r.cohortMonth);
            const months = Object.keys(byCohort).sort();
            const pct = (num, den) => den ? (100*num/den) : 0;
            const avg = arr => arr.length ? _.sum(arr)/arr.length : 0;
            const avg30 = avg(months.map(m => pct(_.sumBy(byCohort[m], r => r.has2nd30?1:0), byCohort[m].length)));
            const avg60 = avg(months.map(m => pct(_.sumBy(byCohort[m], r => r.has2nd60?1:0), byCohort[m].length)));
            const avg90 = avg(months.map(m => pct(_.sumBy(byCohort[m], r => r.has2nd90?1:0), byCohort[m].length)));
            return { months, byCohort, avg30, avg60, avg90 };
            }

            function mdEscape(s){ return String(s).replaceAll('|','\\|'); }

            // ---------- Main generator ----------
            async function generateAIReportMarkdown() {
            const asOf = asOfDateFromDetailed();
            const asOfStr = asOf ? asOf.toISOString().slice(0,10) : '‚Äî';

            // Check which sections to include
            const includeExecutive = document.getElementById('includeExecutive')?.checked ?? true;
            const includeChurn = document.getElementById('includeChurn')?.checked ?? true;
            const includePerformers = document.getElementById('includePerformers')?.checked ?? true;
            const includeFreeFill = document.getElementById('includeFreeFill')?.checked ?? true;

            const sections = [];

            // === EXECUTIVE SUMMARY ===
            if (includeExecutive) {
                const ytdRevenue = _.sumBy(dashboardData.detailed, d => Number(d.revenue) || 0);
                const ytdUnits = _.sumBy(dashboardData.detailed, d => Number(d.quantity) || 0);
                const totalDoors = new Set(dashboardData.detailed.map(d => d.canonical_code)).size;
                const totalInvoices = _.chain(dashboardData.detailed)
                    .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
                    .filter(lines => _.sumBy(lines, 'revenue') > 0)
                    .value().length;
                const avgInvoiceSize = totalInvoices > 0 ? ytdRevenue / totalInvoices : 0;

                sections.push(`# üìä Innovations Report ‚Äî Comprehensive Analytics
**As of:** ${asOfStr}

---

## üéØ Executive Summary

> **Year-to-Date Performance Snapshot**

| Metric | Value |
|--------|------:|
| **Total Revenue** | **$${ytdRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}** |
| **Total Units Sold** | **${ytdUnits.toLocaleString()}** |
| **Active Doors** | **${totalDoors.toLocaleString()}** |
| **Paid Invoices** | **${totalInvoices.toLocaleString()}** |
| **Avg Invoice Size** | **$${avgInvoiceSize.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}** |

---`);
            }

            // === CHURN RISK SECTION ===
            if (includeChurn && dashboardData.churnDetails) {
                const atRiskAccounts = _.chain(Object.entries(dashboardData.churnDetails))
                    .map(([accountId, details]) => ({
                        accountId,
                        risk: details.risk,
                        velocityTrend: details.velocity_trend,
                        daysInCycle: details.days_into_cycle,
                        daysSinceLast: details.days_since_last,
                        medianInterval: details.median_interval
                    }))
                    .filter(a => a.risk >= 0.5)
                    .orderBy(['risk'], ['desc'])
                    .take(15)
                    .value();

                if (atRiskAccounts.length > 0) {
                    const riskTable = [
                        '| Account | Risk % | Days Since Last | Expected Interval | Overdue | Velocity Trend |',
                        '|---------|-------:|----------------:|------------------:|--------:|---------------:|',
                        ...atRiskAccounts.map(a => {
                            const overdue = a.medianInterval > 0 ? (a.daysInCycle).toFixed(1) + 'x' : '‚Äî';
                            const velocityEmoji = a.velocityTrend >= 1.2 ? 'üü¢' : a.velocityTrend >= 0.8 ? '‚ö™' : 'üî¥';
                            return `| ${mdEscape(a.accountId)} | **${(a.risk * 100).toFixed(0)}%** | ${a.daysSinceLast.toFixed(0)}d | ${a.medianInterval.toFixed(0)}d | ${overdue} | ${velocityEmoji} ${a.velocityTrend.toFixed(2)}x |`;
                        })
                    ].join('\n');

                    sections.push(`## ‚ö†Ô∏è Churn Risk Analysis

> **Top At-Risk Accounts** (‚â•50% probability of no reorder within 60 days)

${riskTable}

**Key Indicators:**
- üü¢ **Green velocity** = Ordering faster (accelerating)
- ‚ö™ **Gray velocity** = Stable ordering pattern
- üî¥ **Red velocity** = Ordering slower (decelerating)
- **Overdue >2.0x** = Severely at risk

---`);
                }
            }

            // === TOP/BOTTOM PERFORMERS ===
            if (includePerformers) {
                // Top 5 Products
                const productPerf = _.chain(dashboardData.detailed)
                    .filter(d => d.product_label && String(d.product_label).trim() !== '')
                    .groupBy('product_label')
                    .map((lines, product) => ({
                        product,
                        revenue: _.sumBy(lines, 'revenue'),
                        units: _.sumBy(lines, 'quantity')
                    }))
                    .orderBy(['revenue'], ['desc'])
                    .value();

                const top5Products = _.take(productPerf, 5);
                const bottom5Products = _.takeRight(productPerf, 5).reverse();

                const topProductTable = [
                    '| Product | Revenue | Units |',
                    '|---------|--------:|------:|',
                    ...top5Products.map(p => `| ${mdEscape(p.product)} | $${p.revenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})} | ${p.units.toLocaleString()} |`)
                ].join('\n');

                const bottomProductTable = [
                    '| Product | Revenue | Units |',
                    '|---------|--------:|------:|',
                    ...bottom5Products.map(p => `| ${mdEscape(p.product)} | $${p.revenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})} | ${p.units.toLocaleString()} |`)
                ].join('\n');

                // Top 5 Distributors
                const distPerf = _.chain(dashboardData.detailed)
                    .filter(d => d.distributor && String(d.distributor).trim() !== '')
                    .groupBy('distributor')
                    .map((lines, distributor) => ({
                        distributor,
                        revenue: _.sumBy(lines, 'revenue'),
                        doors: new Set(lines.map(l => l.canonical_code)).size
                    }))
                    .orderBy(['revenue'], ['desc'])
                    .take(5)
                    .value();

                const topDistTable = [
                    '| Distributor | Revenue | Active Doors |',
                    '|-------------|--------:|-------------:|',
                    ...distPerf.map(d => `| ${mdEscape(d.distributor)} | $${d.revenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})} | ${d.doors.toLocaleString()} |`)
                ].join('\n');

                sections.push(`## üèÜ Top Performers

### ü•á Top 5 Products by Revenue
${topProductTable}

### üìà Top 5 Distributors by Revenue
${topDistTable}

---

## üìâ Bottom Performers

### ‚ö†Ô∏è Bottom 5 Products by Revenue
${bottomProductTable}

> **Note:** Focus on whether bottom performers need marketing support or should be phased out.

---`);
            }

            // === FREE FILL ANALYSIS ===
            if (includeFreeFill) {
                const freeFillLines = dashboardData.detailed.filter(d => String(d.reason_for_no_charge || '').toLowerCase().includes('free fill'));
                const freeFillRevenue = _.sumBy(freeFillLines, d => Number(d.revenue) || 0);
                const freeFillUnits = _.sumBy(freeFillLines, d => Number(d.quantity) || 0);
                const freeFillAccounts = new Set(freeFillLines.map(d => d.canonical_code)).size;

                // Conversion: accounts with free fill who also have paid invoices
                const freeFillAccountIds = new Set(freeFillLines.map(d => d.canonical_code));
                const paidLines = dashboardData.detailed.filter(d => Number(d.revenue) > 0);
                const convertedAccounts = new Set(paidLines.filter(d => freeFillAccountIds.has(d.canonical_code)).map(d => d.canonical_code)).size;
                const conversionRate = freeFillAccounts > 0 ? (convertedAccounts / freeFillAccounts) * 100 : 0;

                sections.push(`## üéÅ Free Fill Analysis

> **Free Fill Program Performance**

| Metric | Value |
|--------|------:|
| **Free Fill Revenue** | $${freeFillRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})} |
| **Free Fill Units** | ${freeFillUnits.toLocaleString()} |
| **Free Fill Accounts** | ${freeFillAccounts.toLocaleString()} |
| **Converted to Paid** | ${convertedAccounts.toLocaleString()} |
| **Conversion Rate** | **${conversionRate.toFixed(1)}%** |

**Interpretation:**
- ${conversionRate >= 50 ? 'üü¢ **Strong conversion** ‚Äî Free fill is driving paid orders' : conversionRate >= 30 ? 'üü° **Moderate conversion** ‚Äî Some accounts converting to paid' : 'üî¥ **Low conversion** ‚Äî Consider strategy adjustment'}
- ${freeFillAccounts > 0 ? `Average units per free fill account: ${(freeFillUnits / freeFillAccounts).toFixed(1)}` : 'No free fill activity'}

---`);
            }

            // === ORIGINAL SECTIONS (Always included) ===
            // YEP / Plan
            const planRows = extractYEPPlanRows();
            const planTable = [
                '| Product | FY Plan | YEP ($) | Pace |',
                '|---|---:|---:|---:|',
                ...planRows.map(r => `| ${mdEscape(r.product)} | ${r.fyPlan!=null ? r.fyPlan.toLocaleString() : '‚Äî'} | ${r.yep.toLocaleString()} | ${r.pace!=null ? (r.pace*100).toFixed(0)+'%' : '‚Äî'} |`)
            ].join('\n');

            sections.push(`## üìÖ Year-End Projection vs Plan
${planTable}

---`);

            // Weekly Velocity (Overall + Top 3 Distributor + Top 3 Rep)
            const overall = buildWeeklyData('overall');
            const dist = buildWeeklyData('distributor');
            const rep = buildWeeklyData('rep');

            function narrativeFor(byKey, weeks, labelFn) {
                const records = Object.keys(byKey).map(k => {
                const arr = byKey[k];
                const doors = weeks.map(w => (arr.find(x => x.week===w)?.doors) ?? 0);
                const opa   = weeks.map(w => (arr.find(x => x.week===w)?.opa)   ?? 1);
                const rpd   = weeks.map(w => (arr.find(x => x.week===w)?.rpd)   ?? 0);
                const doorsSum = _.sum(doors);
                const { summary, bullets } = summarizeSeriesForReport(weeks, doors, opa, rpd);
                return { k, label: labelFn(k), doorsSum, summary, bullets };
                });
                const top = _.take(_.orderBy(records, ['doorsSum'], ['desc']), 3);
                return top.map(r =>
                `**${r.label}**\n\n${r.summary}\n\n- ${r.bullets.join('\n- ')}\n`).join('\n');
            }

            const overallNarr =
                (() => {
                const k = Object.keys(overall.byKey)[0];
                const arr = overall.byKey[k];
                const doors = overall.allWeeks.map(w => (arr.find(x => x.week===w)?.doors) ?? 0);
                const opa   = overall.allWeeks.map(w => (arr.find(x => x.week===w)?.opa)   ?? 1);
                const rpd   = overall.allWeeks.map(w => (arr.find(x => x.week===w)?.rpd)   ?? 0);
                const { summary, bullets } = summarizeSeriesForReport(overall.allWeeks, doors, opa, rpd);
                return `${summary}\n\n- ${bullets.join('\n- ')}`;
                })();

            const distNarr = narrativeFor(dist.byKey, dist.allWeeks, k => k);
            const repNarr  = narrativeFor(rep.byKey,  rep.allWeeks,  k => (salesRepMap[String(k)] || 'Unassigned'));

            sections.push(`## üìä Weekly Velocity ‚Äî Overall
${overallNarr}

---

## üìä Weekly Velocity ‚Äî Top Distributors
${distNarr || '_No distributor data_'}

---

## üìä Weekly Velocity ‚Äî Top Sales Reps
${repNarr || '_No rep data_'}

---`);

            // Cohort
            const { months, byCohort, avg30, avg60, avg90 } = buildCohortData();

            sections.push(`## üîÑ Cohort Retention (Accounts)

Each cohort = accounts (canonical_code) with a **first** paid invoice in that month; lines show % placing a **second** order within 30/60/90 days.

- Average reorder ‚â§30 days: **${isFinite(avg30)?avg30.toFixed(0):'‚Äî'}%**
- Average reorder ‚â§60 days: **${isFinite(avg60)?avg60.toFixed(0):'‚Äî'}%**
- Average reorder ‚â§90 days: **${isFinite(avg90)?avg90.toFixed(0):'‚Äî'}%**

**Interpretation:**
${avg30 >= 40 ? 'üü¢ Strong early retention' : avg30 >= 20 ? 'üü° Moderate early retention' : 'üî¥ Weak early retention ‚Äî consider onboarding improvements'}

Monotonic curves are expected (‚â§30 ‚â• ‚â§60 ‚â• ‚â§90). Higher early percentages indicate faster loyalty formation.

---

_Report generated on ${new Date().toISOString().slice(0,10)}_`);

            return sections.join('\n\n');
            }

            function attachAIReportHandlers() {
            const btnGen = document.getElementById('btnGenerateAIReport');
            const btnCopy = document.getElementById('btnCopyAIReport');
            const btnDl  = document.getElementById('btnDownloadAIReport');
            const out    = document.getElementById('aiReportOutput');
            if (!btnGen || !btnCopy || !btnDl || !out) return;

            btnGen.onclick = async () => {
                try {
                const md = await generateAIReportMarkdown();
                out.value = md;

                // Enable Copy and Download buttons
                btnCopy.disabled = false;
                btnCopy.style.opacity = 1;
                btnCopy.style.cursor = 'pointer';
                btnDl.disabled = false;
                btnDl.style.opacity = 1;
                btnDl.style.cursor = 'pointer';

                // Update Download button handler
                btnDl.onclick = () => {
                    const blob = new Blob([md], {type:'text/markdown'});
                    const asOf = asOfDateFromDetailed();
                    const name = `innovations_ai_report_${asOf ? asOf.toISOString().slice(0,10) : 'na'}.md`;
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = name;
                    a.click();
                    URL.revokeObjectURL(a.href);
                };

                // Update Copy button handler
                btnCopy.onclick = async () => {
                    try {
                        await navigator.clipboard.writeText(md);
                        const originalText = btnCopy.innerHTML;
                        btnCopy.innerHTML = '‚úì Copied!';
                        btnCopy.style.background = '#10b981';
                        setTimeout(() => {
                            btnCopy.innerHTML = originalText;
                            btnCopy.style.background = '';
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                        alert('Failed to copy to clipboard. Please select and copy the text manually.');
                    }
                };
                } catch (e) {
                console.error('AI report generation failed:', e);
                out.value = `Error generating report: ${e.message || e}`;
                btnCopy.disabled = true;
                btnCopy.style.opacity = 0.7;
                btnDl.disabled = true;
                btnDl.style.opacity = 0.7;
                }
            };
        }


        // --- Doors calculator on a dataset of invoices ---
        function calcDoors(invoices) {
        // Doors = unique canonical_code with ‚â•1 paid invoice
        return new Set(invoices.map(i => i.canonical_code)).size;
        }
        function calcOPA(invoices) {
        const doors = calcDoors(invoices);
        return doors ? (invoices.length / doors) : 0;
        }
        function calcRPD(invoices) {
        const doors = calcDoors(invoices);
        const rev = _.sumBy(invoices, i => Number(i.revenue) || 0);
        return doors ? (rev / doors) : 0;
        }

        
        // Product launch information
        const newProducts = {
            'Q1': [
                { name: 'Collagen Beauty', code: 'IN059212', upc: '7-10363-59212-7' },
                { name: 'Ashwagandha Healthy Brain Mood & Stress', code: 'IN051231', upc: '8-40081-41231-2' }
            ],
            'Q2': [
                { name: 'Magnesium + Beets & CoQ10', code: 'IN051308', upc: '8-40081-41308-1' },
                { name: 'Magnesium + Milk Thistle & Turmeric', code: 'IN051312', upc: '8-40081-41312-8' },
                { name: 'Power to Sleep Magnesium PM + Relaxing Flower Complex', code: 'IN051316', upc: '8-40081-41316-6' },
                { name: 'Turbo-Energy Libido-Max RED', code: 'IN051304', upc: '8-40081-41304-3' }
            ],
            'Q4': [
                { name: 'Milk Thistle Triple-Detox', code: 'IN051326', upc: '8-40081-41326-5' },
                { name: 'Alpha-Choline Brain & Muscle Support Extra-Strength', code: 'IN051322', upc: '8-40081-41322-7' }
            ]
        };
        
        // Innovation product UPCs (normalized 12-digit)
        const innovationUPCs = [
            '710363592127', // Collagen Beauty
            '840081412312', // Ashwagandha Healthy Brain Mood & Stress
            '840081413081', // Magnesium + Beets & CoQ10
            '840081413128', // Magnesium + Milk Thistle & Turmeric
            '840081413166', // Power to Sleep Magnesium PM + Relaxing Flower Complex
            '840081413043', // Turbo-Energy Libido-Max RED
            '840081413265', // Milk Thistle Triple-Detox
            '840081413227'  // Alpha-Choline Brain & Muscle Support Extra-Strength
        ];

        // Map product names to UPCs for filtering
        const productNameToUPC = {
            'Collagen Beauty': '710363592127',
            'Ashwagandha Healthy Brain Mood & Stress': '840081412312',
            'Magnesium + Beets & CoQ10': '840081413081',
            'Magnesium + Milk Thistle & Turmeric': '840081413128',
            'Power to Sleep Magnesium PM + Relaxing Flower Complex': '840081413166',
            'Turbo-Energy Libido-Max RED': '840081413043',
            'Milk Thistle Triple-Detox': '840081413265',
            'Alpha-Choline Brain & Muscle Support Extra-Strength': '840081413227'
        };

        // Create inverse mapping: UPC to canonical product name
        const upcToCanonicalName = Object.fromEntries(
            Object.entries(productNameToUPC).map(([name, upc]) => [upc, name])
        );

        // Keep product names for display purposes
        const newProductsList = [
            'Collagen Beauty',
            'Ashwagandha Healthy Brain Mood & Stress',
            'Magnesium + Beets & CoQ10',
            'Magnesium + Milk Thistle & Turmeric',
            'Power to Sleep Magnesium PM + Relaxing Flower Complex',
            'Turbo-Energy Libido-Max RED',
            'Milk Thistle Triple-Detox',
            'Alpha-Choline Brain & Muscle Support Extra-Strength'
        ];

        // Helper function to fetch and parse CSV data
        async function loadCSV(filePath) {
            const response = await fetch(filePath);
            const text = await response.text();
            return Papa.parse(text, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true
            }).data;
        }
        
        // Initialize dashboard
        async function initializeDashboard() {
        try {
            await runDataDiagnostics(); // You can leave this in or remove it

        // Load everything in parallel
        const [
        monthlyData,
        salesRepData,
        distributorData,
        accountsData,
        detailedData,
        planTargetsMaybe,
        top10Maybe,
        launchesMaybe,
        churnMaybe
        ] = await Promise.all([
        loadCSV('data/summary_monthly.csv'),
        loadCSV('data/summary_salesrep.csv'),
        loadCSV('data/summary_distributor.csv'),
        loadCSV('data/summary_accounts_top50.csv'),
        loadCSV('data/innovations_transactions_2025.csv'),

        // plan (optional)
        fetch('data/plan_targets_2025_annual_template.csv')
            .then(r => r.ok ? r.text() : null)
            .then(t => t ? Papa.parse(t, { header:true, dynamicTyping:true, skipEmptyLines:true }).data : null),

        // top10 (optional)
        fetch('data/top_10_overall_skus.csv')
            .then(r => r.ok ? r.text() : null)
            .then(t => t ? Papa.parse(t, { header:true, dynamicTyping:true, skipEmptyLines:true }).data : null),

        // launches (optional)
        fetch('data/launches_performance.csv')
            .then(r => r.ok ? r.text() : null)
            .then(t => t ? Papa.parse(t, { header:true, dynamicTyping:true, skipEmptyLines:true }).data : null),

        // churn predictions (optional)
        fetch('data/churn_predictions_60d.csv')
            .then(r => r.ok ? r.text() : null)
            .then(t => t ? Papa.parse(t, { header:true, dynamicTyping:true, skipEmptyLines:true }).data : null),
        ]);

        // Stash
        dashboardData.planTargets = planTargetsMaybe || null;
        dashboardData.top10 = top10Maybe || [];
        dashboardData.launches = launchesMaybe || [];
        // Store both the risk map (for quick lookup) and full churn data (for detailed metrics)
        dashboardData.riskByAccount = (churnMaybe || []).reduce((acc, r) => {
        acc[String(r.account_id)] = Number(r.risk_prob_reorder_60d);
        return acc;
        }, {});
        dashboardData.churnDetails = (churnMaybe || []).reduce((acc, r) => {
        acc[String(r.account_id)] = {
            risk: Number(r.risk_prob_reorder_60d),
            velocity_trend: Number(r.velocity_trend) || 1.0,
            days_into_cycle: Number(r.days_into_cycle) || 0,
            days_since_last: Number(r.days_since_last) || 0,
            median_interval: Number(r.median_interval_recent5) || 0,
            is_severely_overdue: Number(r.is_severely_overdue) || 0,
            is_high_frequency: Number(r.is_high_frequency) || 0,
        };
        return acc;
        }, {});


            // 1. Create a single, clean master dataset from the detailed file
            // Filter by UPC instead of product name (product names have inconsistent formatting)
            // Note: Convert UPC to string because Papa Parse dynamicTyping may convert to number
            let masterData = detailedData.filter(d =>
                d.year === 2025 && innovationUPCs.includes(String(d.upc_item_code_norm12))
            );

            console.log(`%c[DATA FILTER] Loaded ${detailedData.length} total rows, filtered to ${masterData.length} innovation product rows`, 'color: cyan; font-weight: bold');
            console.log(`%c[DATA FILTER] Total revenue in filtered data: $${_.sumBy(masterData.filter(d => d.revenue > 0), 'revenue').toLocaleString()}`, 'color: cyan; font-weight: bold');

            // CRITICAL FIX: Normalize all product names to canonical names based on UPC
            // This prevents issues with product name variations like "COLLAGEN BEAUTY 80CAP" vs "Collagen Beauty"
            // Now all downstream groupBy operations will use consistent canonical names
            masterData = masterData.map(d => ({
                ...d,
                product_name: upcToCanonicalName[String(d.upc_item_code_norm12)] || d.product_name
            }));

            console.log(`%c[DATA NORMALIZATION] Normalized ${masterData.length} rows to canonical product names`, 'color: lime; font-weight: bold');

            // --- THIS IS THE FIX ---
            // Assign the clean master data to the .detailed object
            dashboardData.detailed = masterData;
            // --------------------

            // 2. Re-create the 'monthly' summary from the master data
            dashboardData.monthly = _.chain(masterData)
                .groupBy(d => {
                    // Handle both string and Date posting_date
                    const pd = d.posting_date;
                    if (typeof pd === 'string') return pd.substring(0,7);
                    if (pd instanceof Date) return `${pd.getFullYear()}-${String(pd.getMonth()+1).padStart(2,'0')}`;
                    return 'unknown';
                })
                .flatMap((monthRecords, monthKey) => 
                    _.chain(monthRecords)
                        .groupBy('product_name')
                        .map((productRecords, productName) => ({
                            month: `${monthKey}-01`,
                            product_name: productName,
                            revenue: _.sumBy(productRecords, 'revenue'),
                            units: _.sumBy(productRecords, 'quantity'),
                            txn_count: productRecords.length
                        }))
                        .value()
                )
                .value();
            
            // (The rest of the function remains the same)
            dashboardData.distributor = _.chain(masterData)
                .groupBy(d => `${d.distributor}-${d.product_name}`)
                .map((records, key) => ({
                    distributor: records[0].distributor,
                    product_name: records[0].product_name,
                    revenue_ytd: _.sumBy(records, 'revenue'),
                    units_ytd: _.sumBy(records, 'quantity'),
                    txn_count: records.length
                }))
                .value();

            dashboardData.salesRep = _.chain(masterData)
                 .groupBy(d => `${d.sales_rep}-${d.product_name}`)
                .map((records, key) => ({
                    sales_rep: records[0].sales_rep,
                    product_name: records[0].product_name,
                    revenue_ytd: _.sumBy(records, 'revenue'),
                    units_ytd: _.sumBy(records, 'quantity'),
                    txn_count: records.length
                }))
                .value();
            
            dashboardData.accounts = _.chain(masterData)
                .groupBy(d => `${d.canonical_code}-${d.product_name}`)
                .map((records, key) => ({
                    canonical_code: records[0].canonical_code,
                    product_name: records[0].product_name,
                    revenue_ytd: _.sumBy(records, 'revenue'),
                    units_ytd: _.sumBy(records, 'quantity'),
                    txn_count: records.length
                }))
                .value();

            populateProductPills();
            calculateKPIs();
            createCharts();
            populateTables();
            generateAdvancedInsights();

            // --- ADD THIS CODE TO THE END OF initializeDashboard ---

            // Setup for the Product Deep Dive tab
            const productSelector = document.getElementById('productSelector');
            
            // Populate the dropdown with the list of new products
            newProductsList.forEach(product => {
                const option = document.createElement('option');
                option.value = product;
                option.textContent = product;
                productSelector.appendChild(option);
            });

            // Add an event listener to update the tab when the selection changes
            productSelector.addEventListener('change', (event) => {
                updateProductDeepDive(event.target.value);
            });

            // Trigger an initial update for the default selected product
            updateProductDeepDive(productSelector.value);

            // --- END OF ADDED CODE ---

            
            document.getElementById('loadingOverlay').style.display = 'none';
            
        } catch (error) {
            console.error('Error initializing dashboard:', error);
            document.getElementById('loadingOverlay').innerHTML = 
                `<div style="color: #ff6b6b;">Error initializing dashboard: ${error.message}</div>`;
        }
    }
    function ytdPlanFor(scopeType, scopeId, asOfDate) {
        if (!dashboardData.planTargets) return null;
        const asOf = new Date(asOfDate.getFullYear(), asOfDate.getMonth(), 1);
        const rows = dashboardData.planTargets.filter(r =>
            (r.scope_type === scopeType) &&
            (String(r.scope_id) === String(scopeId)) &&
            r.month && new Date(r.month) <= asOf
        );
        if (!rows.length) return null;
        return _.sumBy(rows, r => Number(r.plan_revenue) || 0);
    }

    function fyPlanFor(scopeType, scopeId) {
        if (!dashboardData.planTargets) return null;
        const rows = dashboardData.planTargets.filter(r =>
            (r.scope_type === scopeType) &&
            (String(r.scope_id) === String(scopeId))
        );
        if (!rows.length) return null;
        return _.sumBy(rows, r => Number(r.plan_revenue) || 0);
    }


        
    function populateProductPills() {
        const container = document.getElementById('productPills');
        for (const [quarter, products] of Object.entries(newProducts)) {
            products.forEach(product => {
                const pill = document.createElement('div');
                pill.className = 'product-pill';
                pill.innerHTML = `${product.name} <span class="quarter">${quarter}</span>`;
                container.appendChild(pill);
            });
        }
    }
        
        function calculateKPIs() {
    const data2025 = dashboardData.detailed;

    // --- 1. INVOICE-LEVEL CALCULATIONS ---
    const invoices = _.chain(data2025)
        .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
        .map(lines => ({
            totalRevenue: _.sumBy(lines, 'revenue')
        }))
        .value();
    const paidInvoices = invoices.filter(inv => inv.totalRevenue > 0);
    const totalPaidInvoiceRevenue = _.sumBy(paidInvoices, 'totalRevenue');
    const paidInvoiceCount = paidInvoices.length;
    const invoiceAOV = paidInvoiceCount > 0 ? totalPaidInvoiceRevenue / paidInvoiceCount : 0;

    // --- 2. ACCOUNT COUNT CALCULATIONS ---
    const accountSummary = createAccountSummaryData();
    const paidAccountsCount = accountSummary.length;
    const totalAccountsWithActivity = _.uniqBy(data2025, 'canonical_code').length;

    // --- 3. YEAR-END PROJECTION (YEP) CALCULATION ---
    const monthlyAggregated = _.chain(data2025).groupBy(d => `${d.product_name}-${d.posting_date.substring(0, 7)}`).map(records => ({ product_name: records[0].product_name, month: records[0].posting_date.substring(0, 7), revenue: _.sumBy(records, 'revenue') })).value();
    const latestMonth = _.chain(monthlyAggregated).map(d => parseAsLocalDate(`${d.month}-01`)).maxBy(d => d.getTime()).value();
    const latestMonthIndex = latestMonth ? latestMonth.getMonth() : 8;
    const productProjections = _.chain(monthlyAggregated).groupBy('product_name').map((monthlyRecords, name) => {
        const sortedMonths = _.orderBy(monthlyRecords, 'month', 'asc');
        const ytdActual = _.sumBy(sortedMonths, 'revenue');
        let launchMonth = 0;
        for (const [quarter, products] of Object.entries(newProducts)) { if (products.some(p => p.name === name)) { if (quarter === 'Q2') launchMonth = 3; else if (quarter === 'Q3') launchMonth = 6; else if (quarter === 'Q4') launchMonth = 9; break; } }
        const remainingMonthsInYear = 11 - latestMonthIndex;
        const remainingMonths = launchMonth > latestMonthIndex ? (11 - launchMonth + 1) : remainingMonthsInYear;
        const recentMonths = sortedMonths.slice(-3);
        const avgRecentMonthlyRevenue = _.meanBy(recentMonths, 'revenue') || 0;
        let growthTrend = 0;
        if (recentMonths.length > 1) { const first = recentMonths[0].revenue; const last = recentMonths[recentMonths.length - 1].revenue; growthTrend = first > 0 ? (last - first) / first : 0; }
        const cappedGrowth = Math.min(Math.max(growthTrend, -0.1), 0.20);
        const projectedMonthly = avgRecentMonthlyRevenue * (1 + cappedGrowth) * 0.95;
        const projectedRemaining = projectedMonthly * remainingMonths;
        const totalYEP = ytdActual + projectedRemaining;
        return { totalYEP };
    }).value();
    const totalYEPValue = _.sumBy(productProjections, 'totalYEP');

    // --- 4. STANDARD KPI CALCULATIONS ---
    const totalRevenue = _.sumBy(data2025, 'revenue');
    const totalUnits = _.sumBy(data2025, 'quantity');
    const totalLineItems = data2025.length;
    const uniqueMonths = _.uniqBy(data2025, d => d.posting_date.substring(0, 7)).length;
    const avgMonthlyRevenue = uniqueMonths > 0 ? totalRevenue / uniqueMonths : 0;
    const distributorCount = _.uniqBy(data2025, 'distributor').length;

    // --- 5. BUILD THE KPI CARD ARRAY ---
    const kpis = [
        { label: 'YTD Revenue', value: `$${totalRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})}`, change: `$${avgMonthlyRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})} Avg/Month` },
        { label: 'YEP Revenue', value: `$${totalYEPValue.toLocaleString('en-US', {maximumFractionDigits: 0})}`, change: 'Projected Year-End' },
        { label: 'Total Units Sold', value: totalUnits.toLocaleString(), change: '' },
        { label: 'Total Transactions', value: paidInvoiceCount.toLocaleString(), change: `${totalLineItems.toLocaleString()} line items` },
        { label: 'Avg Order Value (Invoice)', value: `$${invoiceAOV.toFixed(2)}`, change: 'Per paid invoice' },
        { label: 'Active Distributors', value: distributorCount, change: '' },
        { label: 'Active Sales Reps', value: _.uniqBy(data2025.filter(d => d.sales_rep), 'sales_rep').length, change: '' },
        { label: 'Paid Accounts', value: paidAccountsCount.toLocaleString(), change: `${totalAccountsWithActivity.toLocaleString()} with any activity` },
        { label: 'Products Launched', value: '8', change: 'Data since Jan 2025' }
    ];
    
    // --- 6. RENDER THE CARDS ---
    const grid = document.getElementById('kpiGrid');
    grid.innerHTML = '';
    kpis.forEach(kpi => {
        const card = document.createElement('div');
        card.className = 'kpi-card';
        card.innerHTML = `
            <div class="label">${kpi.label}</div>
            <div class="value">${kpi.value}</div>
            <div class="change">${kpi.change}</div>
        `;
        grid.appendChild(card);
    });
}
                        
        function createCharts() {
            // Chart.js default settings
            Chart.defaults.color = '#e0e0e0';
            Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';
            
            // Revenue by Product
            createRevenueByProduct();
            
            // Units by Product
            createUnitsByProduct();
            
            // Monthly Trend
            createMonthlyTrend();
            
            // Launch Curves
            createLaunchCurves();
            
            // Cumulative Growth
            createCumulativeGrowth();
            
            // Quarterly Performance
            createQuarterlyPerformance();

            // Year-End Projections
            createYearEndProjection();
            createWeeklyVelocity();
            createCohortRetention();
            attachAIReportHandlers();
            createSkuOverlapAnalysis();
            createAdoptionLagAnalysis();
            // Generate the Free Fill Reorder Analysis chart and stats
            createFreeFillReorderAnalysis();
            createParetoAnalysis()
        }
        
        function createRevenueByProduct() {
            const ctx = document.getElementById('revenueByProduct').getContext('2d');
            const productRevenue = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .mapValues(records => _.sumBy(records, 'revenue'))
                .value();
            
            // Destroy the old chart instance if it exists
            if (charts.revenueByProduct) {
                charts.revenueByProduct.destroy();
            }

            charts.revenueByProduct = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(productRevenue),
                    datasets: [{
                        label: 'Revenue ($)',
                        data: Object.values(productRevenue),
                        backgroundColor: [
                            'rgba(102, 126, 234, 0.8)','rgba(118, 75, 162, 0.8)','rgba(240, 147, 251, 0.8)','rgba(245, 87, 108, 0.8)',
                            'rgba(74, 222, 128, 0.8)','rgba(251, 191, 36, 0.8)','rgba(239, 68, 68, 0.8)','rgba(34, 197, 94, 0.8)'
                        ],
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `$${context.raw.toLocaleString('en-US', {maximumFractionDigits: 0})}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return `$${(value/1000).toFixed(0)}K`;
                                }
                            }
                        },
                        x: {
                            ticks: { display: false }
                        }
                    }
                }
            });
        }
        
        function createUnitsByProduct() {
            const ctx = document.getElementById('unitsByProduct').getContext('2d');
            const productUnits = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .mapValues(records => _.sumBy(records, 'units'))
                .value();
            
            // Destroy the old chart instance if it exists
            if (charts.unitsByProduct) {
                charts.unitsByProduct.destroy();
            }

            charts.unitsByProduct = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(productUnits),
                    datasets: [{
                        data: Object.values(productUnits),
                        backgroundColor: [
                            'rgba(102, 126, 234, 0.8)','rgba(118, 75, 162, 0.8)','rgba(240, 147, 251, 0.8)','rgba(245, 87, 108, 0.8)',
                            'rgba(74, 222, 128, 0.8)','rgba(251, 191, 36, 0.8)','rgba(239, 68, 68, 0.8)','rgba(34, 197, 94, 0.8)'
                        ],
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: { size: 10 }
                            },
                            // This filter function fixes the legend click issue
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                if (ci.isDatasetVisible(index)) {
                                    ci.hide(index);
                                    legendItem.hidden = true;
                                } else {
                                    ci.show(index);
                                    legendItem.hidden = false;
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.raw / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.raw.toLocaleString()} units (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function createMonthlyTrend() {
        const ctx = document.getElementById('monthlyTrend').getContext('2d');
        const monthlyByProduct = _.chain(dashboardData.monthly)
            .groupBy('month')
            .mapValues(monthRecords =>
                _.chain(monthRecords)
                    .groupBy('product_name')
                    .mapValues(records => _.sumBy(records, 'revenue'))
                    .value()
            )
            .value();

        // Use string sorting which is safe for 'YYYY-MM-DD' format
        const months = Object.keys(monthlyByProduct).sort();
        const products = newProductsList;

        // Generate 3 future months for forecasting
        const lastMonth = parseAsLocalDate(months[months.length - 1]);
        const futureMonths = [];
        for (let i = 1; i <= 3; i++) {
            const futureDate = new Date(lastMonth.getFullYear(), lastMonth.getMonth() + i, 1);
            const futureMonthStr = `${futureDate.getFullYear()}-${String(futureDate.getMonth() + 1).padStart(2, '0')}-01`;
            futureMonths.push(futureMonthStr);
        }
        const allMonths = [...months, ...futureMonths];

        // Create actual data datasets
        const actualDatasets = products.map((product, index) => {
            const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbf24', '#ef4444', '#22c55e'][index % 8];
            const actualData = months.map(month => monthlyByProduct[month]?.[product] || 0);

            // Pad with nulls for future months
            const paddedData = [...actualData, ...Array(futureMonths.length).fill(null)];

            return {
                label: product,
                data: paddedData,
                borderColor: color,
                backgroundColor: `${color}1A`, // Lighter fill
                tension: 0.4,
                fill: true,
                spanGaps: false // Don't connect actual to forecast
            };
        });

        // Create forecast datasets (dashed lines)
        const forecastDatasets = products.map((product, index) => {
            const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbf24', '#ef4444', '#22c55e'][index % 8];
            const actualData = months.map(month => monthlyByProduct[month]?.[product] || 0);

            // Simple forecasting: average of last 3 months
            const last3Months = actualData.slice(-3).filter(v => v > 0);
            const avgLast3 = last3Months.length > 0 ? _.mean(last3Months) : 0;

            // Calculate trend (linear growth/decline)
            let trend = 0;
            if (last3Months.length >= 2) {
                const firstHalf = _.mean(last3Months.slice(0, Math.floor(last3Months.length / 2)));
                const secondHalf = _.mean(last3Months.slice(Math.floor(last3Months.length / 2)));
                trend = secondHalf - firstHalf;
            }

            // Project forward with trend
            const forecastData = Array(months.length).fill(null);
            forecastData.push(actualData[actualData.length - 1]); // Connect to last actual point

            for (let i = 1; i <= futureMonths.length; i++) {
                const projected = Math.max(0, avgLast3 + (trend * i * 0.5)); // Dampen trend by 50%
                forecastData.push(projected);
            }

            return {
                label: `${product} (Forecast)`,
                data: forecastData,
                borderColor: color,
                backgroundColor: `${color}00`, // Transparent fill
                borderDash: [5, 5], // Dashed line
                borderWidth: 2,
                tension: 0.4,
                fill: false,
                pointRadius: 0, // No points on forecast line
                pointHoverRadius: 0
            };
        });

        if (charts.monthlyTrend) charts.monthlyTrend.destroy();
        charts.monthlyTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: allMonths.map(m => parseAsLocalDate(m).toLocaleDateString('en-US', { month: 'short', year: '2-digit' })),
                datasets: [...actualDatasets, ...forecastDatasets]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 15,
                            font: { size: 10 },
                            filter: (item) => !item.text.includes('(Forecast)') // Hide forecast from legend
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y;
                                if (value === null) return null;
                                const prefix = label.includes('Forecast') ? 'Projected: ' : '';
                                return `${label}: ${prefix}$${value.toLocaleString('en-US', {maximumFractionDigits: 0})}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        stacked: false,
                        ticks: { callback: v => `$${(v/1000).toFixed(0)}K` }
                    }
                }
            }
        });
    }

        function createLaunchCurves() {
            const ctx = document.getElementById('launchCurves').getContext('2d');
            
            const productData = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .map((records, name) => {
                    const sortedRecords = _.orderBy(records, 'month', 'asc');
                    return {
                        name: name,
                        revenueTrajectory: sortedRecords.map(r => r.revenue)
                    };
                })
                .value();

            const maxMonths = _.max(productData.map(p => p.revenueTrajectory.length)) || 0;
            const labels = Array.from({ length: maxMonths }, (_, i) => `Month ${i + 1}`);

            const datasets = productData.map((p, index) => {
                const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbf24', '#ef4444', '#22c55e'][index % 8];
                return {
                    label: p.name,
                    data: p.revenueTrajectory,
                    borderColor: color,
                    backgroundColor: `${color}33`,
                    tension: 0.4,
                    fill: false
                };
            });

            charts.launchCurves = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'bottom' } },
                    scales: {
                        x: { title: { display: true, text: 'Months Since Launch' } },
                        y: { title: { display: true, text: 'Monthly Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } }
                    }
                }
            });
        }

        function createCumulativeGrowth() {
            const ctx = document.getElementById('cumulativeGrowth').getContext('2d');
            
            // Get all unique months from the data and sort them
            const allMonths = _.chain(dashboardData.monthly)
                .map(d => d.month)
                .uniq()
                .sortBy()
                .value();

            const productData = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .map((records, name) => {
                    let cumulative = 0;
                    const monthlyRevenue = _.chain(records)
                        .keyBy('month')
                        .mapValues('revenue')
                        .value();

                    // Create a full data series, carrying over the last value for months with no new sales
                    const cumulativeSeries = allMonths.map(month => {
                        if (monthlyRevenue[month]) {
                            cumulative += monthlyRevenue[month];
                        }
                        return cumulative;
                    });
                    
                    return {
                        name: name,
                        cumulativeRevenue: cumulativeSeries
                    };
                })
                .value();

            const labels = Array.from({ length: allMonths.length }, (_, i) => `Month ${i + 1}`);

            const datasets = productData.map((p, index) => {
                const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbf24', '#ef4444', '#22c55e'][index % 8];
                return {
                    label: p.name,
                    data: p.cumulativeRevenue,
                    borderColor: color,
                    backgroundColor: `${color}80`,
                    fill: true,
                    pointRadius: 2
                };
            });

            charts.cumulativeGrowth = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { title: { display: true, text: 'Months Since Jan 2025'} },
                        y: { 
                            stacked: true,
                            title: { display: true, text: 'Total Cumulative Revenue' },
                            ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } 
                        }
                    }
                }
            });
        }

        function createQuarterlyPerformance() {
        const ctx = document.getElementById('quarterlyPerformance').getContext('2d');
        
        const quarterlyData = _.chain(dashboardData.detailed)
            .filter(d => d.year === 2025)
            .groupBy(d => {
                // Use the new helper function to get the correct local month
                const month = parseAsLocalDate(d.posting_date).getMonth(); // Jan=0, Feb=1, etc.
                const year = '25';
                
                if (month < 3) return `Q1 '${year}`;
                if (month < 6) return `Q2 '${year}`;
                if (month < 9) return `Q3 '${year}`;
                return `Q4 '${year}`;
            })
            .map((records, quarter) => ({
                quarter,
                revenue: _.sumBy(records, 'revenue'),
                units: _.sumBy(records, 'quantity'),
            }))
            .orderBy(d => d.quarter)
            .value();

        if (charts.quarterlyPerformance) charts.quarterlyPerformance.destroy();
        charts.quarterlyPerformance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: quarterlyData.map(d => d.quarter),
                datasets: [
                    { label: 'Revenue', data: quarterlyData.map(d => d.revenue), backgroundColor: '#667eea', yAxisID: 'y' },
                    { label: 'Units Sold', data: quarterlyData.map(d => d.units), borderColor: '#f093fb', type: 'line', yAxisID: 'y1' }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { position: 'bottom' } },
                scales: {
                    y: { type: 'linear', position: 'left', title: { display: true, text: 'Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` }},
                    y1: { type: 'linear', position: 'right', title: { display: true, text: 'Units Sold' }, grid: { drawOnChartArea: false } }
                }
            }
        });
    }

    function createParetoAnalysis() {
        const ctx = document.getElementById('paretoAnalysis').getContext('2d');
        const accountData = createAccountSummaryData(); // Uses our existing helper function
        const sortedAccountData = _.orderBy(accountData, [a => (a.risk_prob_60d ?? -1)], ['desc']);
        const topAccounts = accountData.slice(0, 40); // Analyze the top 40 for a clearer chart

        const totalRevenue = _.sumBy(topAccounts, 'revenueYTD');
        let cumulativeRevenue = 0;

        const cumulativeData = topAccounts.map(acc => {
            cumulativeRevenue += acc.revenueYTD;
            return (cumulativeRevenue / totalRevenue) * 100;
        });

        if (charts.paretoAnalysis) charts.paretoAnalysis.destroy();

        charts.paretoAnalysis = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topAccounts.map((acc, index) => `Rank ${index + 1}`),
                datasets: [
                    {
                        label: 'Revenue by Account',
                        data: topAccounts.map(acc => acc.revenueYTD),
                        backgroundColor: '#667eea',
                        yAxisID: 'y',
                    },
                    {
                        label: 'Cumulative Revenue %',
                        data: cumulativeData,
                        type: 'line',
                        borderColor: '#f093fb',
                        backgroundColor: 'transparent',
                        yAxisID: 'y1',
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.type === 'line') {
                                    return `Cumulative: ${context.raw.toFixed(1)}% of Total Revenue`;
                                }
                                return `Revenue: $${context.raw.toLocaleString()}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { title: { display: true, text: 'Top 40 Accounts by Revenue' } },
                    y: { type: 'linear', position: 'left', title: { display: true, text: 'Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } },
                    y1: { type: 'linear', position: 'right', min: 0, max: 100, title: { display: true, text: 'Cumulative Revenue %' }, grid: { drawOnChartArea: false }, ticks: { callback: v => `${v}%` } }
                }
            }
        });
    }

// --- Helpers ---
function binEdges(step, maxDay) { const arr=[]; for (let d=step; d<=maxDay; d+=step) arr.push(d); return arr; }
function cumulate(arr) { const out=[]; let s=0; for (const v of arr){ s+=v; out.push(s);} return out; }

// --- SKU Overlap (bought-together) ---
function createSkuOverlapAnalysis() {
  const ctx = document.getElementById('skuOverlap')?.getContext('2d');
  if (!ctx || !dashboardData.detailed) return;

  // Use your Launch SKUs to keep matrix small & relevant
  const launches = dashboardData.launches || [];
  if (!launches.length) { /* nothing to show */ return; }

  const launchUPCs = launches.map(r => String(r.upc_norm12)).filter(Boolean);
  const launchNames = launches.map(r => String(r.sku_name)).filter(Boolean);
  const upcToName = Object.fromEntries(launches.map(r => [String(r.upc_norm12), String(r.sku_name)]));

  // Build paid-invoice view then convert to per-account UPC sets (filter by UPC, not name)
  const paid = buildPaidInvoices(dashboardData.detailed);
  const byAcct = _.groupBy(paid, inv => inv.canonical_code);
  const acctSkuSets = Object.values(byAcct).map(recs =>
    new Set(recs.map(r => String(r.upc_item_code_norm12)).filter(upc => launchUPCs.includes(upc)))
  );

  // Counts per SKU and pair overlaps (using names for display, indexed by UPC order)
  const idx = Object.fromEntries(launchUPCs.map((upc,i)=>[upc,i]));
  const buyersA = Array(launchNames.length).fill(0);
  const overlapCounts = Array.from({length: launchNames.length}, () => Array(launchNames.length).fill(0));

  for (const s of acctSkuSets) {
    const arr = Array.from(s);
    for (const a of arr) buyersA[idx[a]]++;
    for (let i=0;i<arr.length;i++){
      for (let j=0;j<arr.length;j++){
        overlapCounts[idx[arr[i]]][idx[arr[j]]] += 1;
      }
    }
  }

  // Convert to conditional attach rate P(B|A) = accounts(both)/accounts(bought A)
  const points = [];
  for (let i=0;i<launchNames.length;i++){
    for (let j=0;j<launchNames.length;j++){
      const denom = buyersA[i] || 0;
      const both = overlapCounts[i][j] || 0;
      const rate = denom ? (both/denom) : 0;
      // bubble radius scaled (min 2px)
      const r = Math.max(2, 30 * Math.sqrt(rate));
      points.push({x:j, y:i, r, rate, both, denom});
    }
  }

  if (charts.skuOverlap) charts.skuOverlap.destroy();
  charts.skuOverlap = new Chart(ctx, {
    type: 'bubble',
    data: {
      labels: launchNames,
      datasets: [{
        label: 'Attach rate P(B|A)',
        data: points.map(p => ({x:p.x, y:p.y, r:p.r})),
        backgroundColor: 'rgba(125, 211, 252, 0.35)',
        borderColor: 'rgba(125, 211, 252, 0.6)',
        borderWidth: 1
      }]
    },
    options: {
      maintainAspectRatio: false,
      plugins: {
        legend: { display:false },
        tooltip: {
          callbacks: {
            title: (items) => {
              const it = items[0]; 
              return `A=${launchNames[it.raw.y]}  B=${launchNames[it.raw.x]}`;
            },
            label: (it) => {
              const p = points[it.dataIndex];
              const pct = (100 * (p.rate||0)).toFixed(0) + '%';
              return [`P(B|A) = ${pct}`, `both=${p.both} / buyers(A)=${p.denom}`];
            }
          }
        }
      },
      scales: {
        x: { type:'linear', min:-0.5, max:launchNames.length-0.5, ticks: {
              callback:(v)=> launchNames[v] ?? ''
            } 
        },
        y: { type:'linear', reverse:true, min:-0.5, max:launchNames.length-0.5, ticks: {
              callback:(v)=> launchNames[v] ?? ''
            }
        }
      }
    }
  });
}

// --- Adoption Lag (time from first to second order) ---
function createAdoptionLagAnalysis() {
  const ctx = document.getElementById('adoptionLag')?.getContext('2d');
  if (!ctx || !dashboardData.detailed) return;

  const launches = dashboardData.launches || [];
  if (!launches.length) return;

  const launchUPCs = launches.map(r => String(r.upc_norm12)).filter(Boolean);
  const launchNames = launches.map(r => String(r.sku_name)).filter(Boolean);

  // Paid invoices, filtered to Launch SKUs only (by UPC, not name)
  const paid = buildPaidInvoices(dashboardData.detailed).filter(inv => launchUPCs.includes(String(inv.upc_item_code_norm12)));

  // For each (account, product): days between first and second invoice
  const byAcctProd = _.groupBy(paid, inv => `${inv.canonical_code}::${inv.product_name}`);
  const lags = []; // in days
  for (const key in byAcctProd) {
    const arr = _.sortBy(byAcctProd[key], inv => inv.posting_date);
    if (arr.length < 2) continue;
    const d = (arr[1].posting_date - arr[0].posting_date) / 86400000; // ms ‚Üí days
    if (isFinite(d) && d >= 0) lags.push(d);
  }
  if (!lags.length) return;

  // Histogram bins & cumulative %
  const edges = binEdges(15, 120); // 15-day bins up to 120
  const bins = edges.map((edge, i) => lags.filter(x => x <= edge && (i===0 || x > edges[i-1])).length);
  const total = lags.length;
  const cumPct = cumulate(bins).map(n => total ? (100*n/total) : 0);
  const labels = edges.map(d => `‚â§${d}d`);

  if (charts.adoptionLag) charts.adoptionLag.destroy();
  charts.adoptionLag = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets: [{ label:'Reorder cumulative % (launch SKUs)', data: cumPct, tension:0.25, fill:false }] },
    options: {
      maintainAspectRatio:false,
      plugins:{ legend:{position:'top'}, tooltip:{ callbacks:{ label:(c)=> `${c.parsed.y.toFixed(0)}%` } } },
      scales:{ y:{ ticks:{ callback:v => v+'%' }, min:0, max:100 } }
    }
  });
}

// --- Free Fill Reorder Analysis ---
// This analysis examines "free fill" shipments (revenue = 0 and quantity 1 or 2) and measures
// how often accounts reorder after receiving the sample. For accounts receiving one or two
// free fills, it reports the number of doors reached, how many reorder within 90 days and
// within the year-to-date (YTD), as well as the average reorder time, number of subsequent
// paid orders, and total reorder revenue. Additional tables summarize results by account,
// by product (SKU), and by free fill type (sample size).
function createFreeFillReorderAnalysis() {
  const canvas = document.getElementById('freeFillReorderChart');
  if (!canvas || !dashboardData.detailed) return;
  const ctx = canvas.getContext('2d');

  // Transaction rows from CSV
  const rows = dashboardData.detailed;
  // Filter zero-revenue lines with quantity exactly 1 or 2 (free fills)
  const free = rows.filter(d => {
    const qty = Number(d.quantity ?? d.units ?? 0);
    const rev = Number(d.revenue ?? 0);
    return rev === 0 && (qty === 1 || qty === 2);
  });
  // Group free fills by account ID (canonical_code)
  const byAcct = _.groupBy(free, d => d.canonical_code);
  const freeAccounts = [];
  for (const acct in byAcct) {
    const events = byAcct[acct];
    // Find earliest free fill per account (by posting_date)
    const earliest = _.minBy(events, e => parseYMD(e.posting_date));
    if (!earliest) continue;
    const date = parseYMD(earliest.posting_date);
    const qty = Number(earliest.quantity ?? earliest.units ?? 0);
    const type = (qty === 2 ? 2 : 1);
    freeAccounts.push({ account: acct, date, type, product: earliest.product_name, quarter: earliest.quarter });
  }
  // Initialize metrics for 1 and 2 free fill cohorts
  const results = {
    1: { total: 0, reorder90: 0, reorderYTD: 0, reorderRate90: 0, reorderRateYTD: 0, avgTime: null, avgOrderCount: null, reorderRevenue: 0 },
    2: { total: 0, reorder90: 0, reorderYTD: 0, reorderRate90: 0, reorderRateYTD: 0, avgTime: null, avgOrderCount: null, reorderRevenue: 0 }
  };
  // Pre-group all paid transactions by account to speed up lookup
  const paid = rows.filter(r => Number(r.revenue ?? 0) > 0);
  const byAcctPaid = _.groupBy(paid, d => d.canonical_code);
  [1, 2].forEach(type => {
    const accounts = freeAccounts.filter(f => f.type === type);
    results[type].total = accounts.length;
    const times = [];
    const counts = [];
    accounts.forEach(f => {
      const list = byAcctPaid[f.account] || [];
      // Only consider orders after the free fill date
      const after = list.filter(x => parseYMD(x.posting_date) > f.date);
      if (after.length > 0) {
        const sorted = _.sortBy(after, a => parseYMD(a.posting_date));
        const diffDays = (parseYMD(sorted[0].posting_date) - f.date) / 86400000;
        times.push(diffDays);
        counts.push(after.length);
        // count reorders within 90 days
        if (diffDays <= 90) results[type].reorder90++;
        // count any reorder YTD (‚â•1 paid invoice)
        results[type].reorderYTD++;
        // accumulate reorder revenue (sum of revenue after free fill for this account)
        const rev = _.sumBy(after, r => Number(r.revenue ?? 0));
        results[type].reorderRevenue += rev;
      }
    });
    if (results[type].total > 0) {
      results[type].reorderRate90 = 100 * results[type].reorder90 / results[type].total;
      results[type].reorderRateYTD = 100 * results[type].reorderYTD / results[type].total;
    }
    results[type].avgTime = times.length ? _.mean(times) : null;
    results[type].avgOrderCount = counts.length ? _.mean(counts) : null;
  });
  // Prepare datasets for Chart.js grouped bar chart
  const labels = ['‚â§90d', 'YTD'];
  const datasets = [1, 2].map(type => ({
    label: `${type} Free Fill`,
    data: [results[type].reorderRate90, results[type].reorderRateYTD],
    backgroundColor: type === 1 ? 'rgba(102,126,234,0.6)' : 'rgba(236,72,153,0.6)'
  }));
  // Destroy existing chart instance if present
  if (charts.freeFillReorder) charts.freeFillReorder.destroy();
  charts.freeFillReorder = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      maintainAspectRatio: false,
      scales: {
        y: {
          min: 0,
          max: Math.max(
            Math.ceil((results[1].reorderRateYTD || 0) / 10) * 10,
            Math.ceil((results[2].reorderRateYTD || 0) / 10) * 10,
            10
          ),
          ticks: { callback: v => v + '%' }
        }
      },
      plugins: {
        legend: { position: 'top' },
        tooltip: {
          callbacks: {
            label: function(c) {
              const type = c.dataset.label.startsWith('1') ? 1 : 2;
              const idx = c.dataIndex;
              const denom = results[type].total;
              const num = idx === 0 ? results[type].reorder90 : results[type].reorderYTD;
              const perc = idx === 0 ? results[type].reorderRate90 : results[type].reorderRateYTD;
              return `${c.dataset.label}: ${perc.toFixed(0)}% (${num}/${denom})`;
            }
          }
        }
      }
    }
  });
  // Render narrative statistics below the chart
  const statsDiv = document.getElementById('freeFillStats');
  const asPct = x => x != null ? x.toFixed(0) + '%' : '‚Äî';
  statsDiv.innerHTML = `
    <div><strong>1 Free Fill:</strong> ${results[1].total.toLocaleString()} accounts. Reordered ‚â§90d: ${results[1].reorder90.toLocaleString()} (${asPct(results[1].reorderRate90)}). Reordered YTD: ${results[1].reorderYTD.toLocaleString()} (${asPct(results[1].reorderRateYTD)}). ${results[1].avgTime != null ? 'Avg reorder time: ' + results[1].avgTime.toFixed(1) + 'd. ' : ''}${results[1].avgOrderCount != null ? 'Avg orders post-free: ' + results[1].avgOrderCount.toFixed(2) + '.' : ''}</div>
    <div style="margin-top:6px;"><strong>2 Free Fills:</strong> ${results[2].total.toLocaleString()} accounts. Reordered ‚â§90d: ${results[2].reorder90.toLocaleString()} (${asPct(results[2].reorderRate90)}). Reordered YTD: ${results[2].reorderYTD.toLocaleString()} (${asPct(results[2].reorderRateYTD)}). ${results[2].avgTime != null ? 'Avg reorder time: ' + results[2].avgTime.toFixed(1) + 'd. ' : ''}${results[2].avgOrderCount != null ? 'Avg orders post-free: ' + results[2].avgOrderCount.toFixed(2) + '.' : ''}</div>
  `;

  // Build detailed account list for table
  const details = [];
  freeAccounts.forEach(f => {
    const list = byAcctPaid[f.account] || [];
    // only orders after free fill
    const after = list.filter(x => parseYMD(x.posting_date) > f.date);
    const reorderCount = after.length;
    const reorderRevenue = _.sumBy(after, r => Number(r.revenue ?? 0));
    let daysToReorder = null;
    let reorderWithin90 = false;
    let reorderWithin365 = false;
    if (after.length > 0) {
      const first = _.minBy(after, r => parseYMD(r.posting_date));
      const diff = (parseYMD(first.posting_date) - f.date) / 86400000;
      daysToReorder = diff;
      reorderWithin90 = diff <= 90;
      reorderWithin365 = diff <= 365;
    }
    details.push({
      account: f.account,
      type: f.type,
      product: f.product,
      quarter: f.quarter,
      freeDate: f.date,
      reorderCount,
      reorderRevenue,
      daysToReorder,
      reorderWithin90,
      reorderWithinYTD: reorderCount > 0
    });
  });
  dashboardData.freeFillDetails = details;
  dashboardData.freeFillResults = results;
  // Populate the tables
  if (typeof createFreeFillAccountTable === 'function') createFreeFillAccountTable();
  if (typeof createFreeFillBySkuTable === 'function') createFreeFillBySkuTable();
  if (typeof createFreeFillByTypeTable === 'function') createFreeFillByTypeTable();
}

// --- Free Fill Account Table ---
// This helper renders a detailed table for each account that received a free fill, showing
// whether they reordered and key metrics. It pulls precomputed details from
// dashboardData.freeFillDetails set by createFreeFillReorderAnalysis().
function createFreeFillAccountTable() {
  const tbl = document.getElementById('freeFillAccountTable');
  if (!tbl || !dashboardData.freeFillDetails) return;
  const details = dashboardData.freeFillDetails;
  // Sort accounts by reorder status (those with reorders first) and by free fill date
  const sorted = _.orderBy(details, [d => (d.reorderCount > 0 ? 0 : 1), 'freeDate'], ['asc', 'asc']);
  // Build table rows
  // Build HTML for header and body separately to avoid nested template literals
  const header = `
    <thead>
      <tr>
        <th>Account</th>
        <th>Free Fill Type</th>
        <th>Product</th>
        <th>Free Fill Date</th>
        <th>Reordered?</th>
        <th>Days to Reorder</th>
        <th># Paid Orders Post-Free</th>
        <th>Revenue Post-Free</th>
      </tr>
    </thead>
  `;
  const bodyRows = sorted.map(d => {
    const reordered = d.reorderCount > 0;
    const dateStr = d.freeDate.toLocaleDateString('en-US');
    const daysStr = d.daysToReorder != null ? d.daysToReorder.toFixed(0) + 'd' : '‚Äî';
    const revenueStr = '$' + d.reorderRevenue.toLocaleString('en-US', { maximumFractionDigits: 0 });
    return '<tr>' +
      '<td>' + d.account + '</td>' +
      '<td>' + d.type + '</td>' +
      '<td>' + (d.product || '‚Äî') + '</td>' +
      '<td>' + dateStr + '</td>' +
      '<td>' + (reordered ? 'Yes' : 'No') + '</td>' +
      '<td>' + daysStr + '</td>' +
      '<td>' + d.reorderCount.toLocaleString() + '</td>' +
      '<td>' + revenueStr + '</td>' +
      '</tr>';
  }).join('');
  tbl.innerHTML = header + '<tbody>' + bodyRows + '</tbody>';
}

// --- Free Fill Reorder by SKU Table ---
// Aggregates free fill outcomes by product (SKU), summarizing how many accounts
// received a free fill for each SKU, how many reordered within YTD, the reorder rate,
// total reorder revenue, and average reorder timing/frequency.
function createFreeFillBySkuTable() {
  const tbl = document.getElementById('freeFillBySkuTable');
  if (!tbl || !dashboardData.freeFillDetails) return;
  const details = dashboardData.freeFillDetails;
  // Group details by product
  const grouped = _.groupBy(details, d => d.product || 'Unknown');
  const rows = [];
  for (const product in grouped) {
    const rec = grouped[product];
    const total = rec.length;
    const reorderYTDCount = rec.filter(r => r.reorderCount > 0).length;
    const reorderRateYTD = total > 0 ? 100 * reorderYTDCount / total : 0;
    // Number of accounts that reordered within 90 days
    const reorder90Count = rec.filter(r => r.reorderWithin90).length;
    const reorderRate90 = total > 0 ? 100 * reorder90Count / total : 0;
    const reorderRev = _.sumBy(rec, r => r.reorderRevenue);
    const avgTime = _.meanBy(rec.filter(r => r.daysToReorder != null), r => r.daysToReorder);
    const avgOrders = _.meanBy(rec.filter(r => r.reorderCount > 0), r => r.reorderCount);
    // Determine quarter from first record; quarter is per product based on original data
    const q = rec[0]?.quarter || '‚Äî';
    rows.push({ product, quarter: q, total, reorderYTDCount, reorderRateYTD, reorder90Count, reorderRate90, reorderRev, avgTime, avgOrders });
  }
  const sorted = _.orderBy(rows, ['quarter', 'reorderRate', 'reorderRev'], ['asc', 'desc', 'desc']);
  // Build table HTML with Quarter column
  let html = '<thead><tr>' +
    '<th>Product</th><th>Quarter</th><th>Free Fill Accounts</th>' +
    '<th>Reordered ‚â§90d</th><th>Reorder Rate ‚â§90d</th>' +
    '<th>Reordered YTD</th><th>Reorder Rate YTD</th>' +
    '<th>Reorder Revenue</th><th>Avg Days to Reorder</th><th>Avg Orders</th>' +
    '</tr></thead><tbody>';
  html += sorted.map(r => {
    return '<tr>' +
      '<td>' + r.product + '</td>' +
      '<td>' + r.quarter + '</td>' +
      '<td>' + r.total.toLocaleString() + '</td>' +
      '<td>' + r.reorder90Count.toLocaleString() + '</td>' +
      '<td>' + (r.reorderRate90.toFixed(1)) + '%</td>' +
      '<td>' + r.reorderYTDCount.toLocaleString() + '</td>' +
      '<td>' + (r.reorderRateYTD.toFixed(1)) + '%</td>' +
      '<td>$' + r.reorderRev.toLocaleString('en-US', { maximumFractionDigits: 0 }) + '</td>' +
      '<td>' + (r.avgTime != null ? r.avgTime.toFixed(1) + 'd' : '‚Äî') + '</td>' +
      '<td>' + (r.avgOrders != null ? r.avgOrders.toFixed(2) : '‚Äî') + '</td>' +
      '</tr>';
  }).join('');
  html += '</tbody>';
  tbl.innerHTML = html;
}

// --- Free Fill Reorder by Sample Size Table ---
// Summarizes outcomes by free fill type (1 vs 2), showing how many accounts were reached,
// how many reordered within 90 days and YTD, reorder rates, total reorder revenue,
// and average reorder timing/frequency.
function createFreeFillByTypeTable() {
  const tbl = document.getElementById('freeFillByTypeTable');
  if (!tbl || !dashboardData.freeFillResults || !dashboardData.freeFillDetails) return;
  const details = dashboardData.freeFillDetails;
  // Determine unique quarters available
  const quarters = _.uniq(details.map(d => d.quarter || '‚Äî')).filter(q => q && q !== '‚Äî').sort();
  const rows = [];
  // Quarter-specific rows
  quarters.forEach(q => {
    [1, 2].forEach(type => {
      const rec = details.filter(d => d.type === type && d.quarter === q);
      const total = rec.length;
      const reorder90 = rec.filter(r => r.reorderWithin90).length;
      const reorderYTD = rec.filter(r => r.reorderCount > 0).length;
      const reorderRate90 = total > 0 ? 100 * reorder90 / total : null;
      const reorderRateYTD = total > 0 ? 100 * reorderYTD / total : null;
      const reorderRev = _.sumBy(rec, r => r.reorderRevenue);
      const avgTime = _.meanBy(rec.filter(r => r.daysToReorder != null), r => r.daysToReorder);
      const avgOrders = _.meanBy(rec.filter(r => r.reorderCount > 0), r => r.reorderCount);
      rows.push({ quarter: q, type, total, reorder90, reorderRate90, reorderYTD, reorderRateYTD, reorderRev, avgTime, avgOrders });
    });
  });
  // YTD summary rows
  [1, 2].forEach(type => {
    const res = dashboardData.freeFillResults[type];
    const rec = details.filter(d => d.type === type);
    const reorderRev = _.sumBy(rec, r => r.reorderRevenue);
    const avgTime = _.meanBy(rec.filter(r => r.daysToReorder != null), r => r.daysToReorder);
    const avgOrders = _.meanBy(rec.filter(r => r.reorderCount > 0), r => r.reorderCount);
    rows.push({ quarter: 'YTD', type,
      total: res.total,
      reorder90: res.reorder90,
      reorderRate90: res.reorderRate90,
      reorderYTD: res.reorderYTD,
      reorderRateYTD: res.reorderRateYTD,
      reorderRev,
      avgTime,
      avgOrders
    });
  });
  // Sort rows: put YTD at bottom, then sort quarters alphabetically (Q1/Q2...)
  const sorted = _.orderBy(rows, [r => (r.quarter === 'YTD' ? 1 : 0), 'quarter', 'type'], ['asc', 'asc', 'asc']);
  // Build table HTML with Quarter column
  let html = '<thead><tr>' +
    '<th>Quarter</th><th>Free Fill Type</th><th>Accounts</th>' +
    '<th>Reordered ‚â§90d</th><th>Reorder Rate ‚â§90d</th>' +
    '<th>Reordered YTD</th><th>Reorder Rate YTD</th>' +
    '<th>Reorder Revenue</th><th>Avg Days to Reorder</th><th>Avg Orders</th>' +
    '</tr></thead><tbody>';
  html += sorted.map(r => {
    return '<tr>' +
      '<td>' + r.quarter + '</td>' +
      '<td>' + r.type + '</td>' +
      '<td>' + r.total.toLocaleString() + '</td>' +
      '<td>' + r.reorder90.toLocaleString() + '</td>' +
      '<td>' + (r.reorderRate90 != null ? r.reorderRate90.toFixed(1) : '‚Äî') + '%</td>' +
      '<td>' + r.reorderYTD.toLocaleString() + '</td>' +
      '<td>' + (r.reorderRateYTD != null ? r.reorderRateYTD.toFixed(1) : '‚Äî') + '%</td>' +
      '<td>$' + r.reorderRev.toLocaleString('en-US', { maximumFractionDigits: 0 }) + '</td>' +
      '<td>' + (r.avgTime != null ? r.avgTime.toFixed(1) + 'd' : '‚Äî') + '</td>' +
      '<td>' + (r.avgOrders != null ? r.avgOrders.toFixed(2) : '‚Äî') + '</td>' +
      '</tr>';
  }).join('');
  html += '</tbody>';
  tbl.innerHTML = html;
}



    function createYearEndProjection() {
    const ctx = document.getElementById('yearEndProjection').getContext('2d');

    // Step 1: Aggregate the detailed data by month first
    // Note: product_name is already normalized to canonical names at data load time
    const monthlyAggregated = _.chain(dashboardData.detailed)
        .groupBy(d => {
            const pd = d.posting_date;
            const month = typeof pd === 'string' ? pd.substring(0,7) : `${pd.getFullYear()}-${String(pd.getMonth()+1).padStart(2,'0')}`;
            return `${d.product_name}-${month}`;
        })
        .map(records => {
            const pd = records[0].posting_date;
            const month = typeof pd === 'string' ? pd.substring(0,7) : `${pd.getFullYear()}-${String(pd.getMonth()+1).padStart(2,'0')}`;
            return {
                product_name: records[0].product_name,
                month: month,
                revenue: _.sumBy(records, 'revenue'),
                units: _.sumBy(records, 'quantity')
            };
        })
        .value();

    const latestMonth = _.chain(monthlyAggregated)
        .map(d => parseAsLocalDate(`${d.month}-01`))
        .maxBy(d => d.getTime())
        .value();

    const latestMonthIndex = latestMonth ? latestMonth.getMonth() : 8;

    // Step 2: Use the monthly aggregated data to create projections (already normalized)
    const productProjections = _.chain(monthlyAggregated)
        .groupBy('product_name')
        .map((monthlyRecords, productName) => {
            const sortedMonths = _.orderBy(monthlyRecords, 'month', 'asc');
            const ytdActual = _.sumBy(sortedMonths, 'revenue');
            const ytdUnits = _.sumBy(sortedMonths, 'units');
            const monthsActive = sortedMonths.length;

            let launchQuarter = 'Q1';
            let launchMonth = 0;
            for (const [quarter, products] of Object.entries(newProducts)) {
                if (products.some(p => p.name === productName)) {
                    launchQuarter = quarter;
                    if (quarter === 'Q1') launchMonth = 0; else if (quarter === 'Q2') launchMonth = 3; else if (quarter === 'Q3') launchMonth = 6; else if (quarter === 'Q4') launchMonth = 9;
                    break;
                }
            }
            
            const remainingMonthsInYear = 11 - latestMonthIndex;
            const remainingMonths = launchMonth > latestMonthIndex ? (11 - launchMonth + 1) : remainingMonthsInYear;
            
            const recentMonths = sortedMonths.slice(-3);
            const avgRecentMonthlyRevenue = _.meanBy(recentMonths, 'revenue') || 0;
            const avgRecentMonthlyUnits = _.meanBy(recentMonths, 'units') || 0;
            
            let growthTrend = 0;
            if (recentMonths.length > 1) {
                const first = recentMonths[0].revenue;
                const last = recentMonths[recentMonths.length - 1].revenue;
                growthTrend = first > 0 ? (last - first) / first : 0;
            }
            
            const cappedGrowth = Math.min(Math.max(growthTrend, -0.1), 0.20);
            const dampeningFactor = 0.95;
            const projectedMonthlyRevenue = avgRecentMonthlyRevenue * (1 + cappedGrowth) * dampeningFactor;
            const projectedMonthlyUnits = avgRecentMonthlyUnits * (1 + cappedGrowth) * dampeningFactor;
            
            const projectedRemaining = projectedMonthlyRevenue * remainingMonths;
            const projectedRemainingUnits = projectedMonthlyUnits * remainingMonths;
            const totalYEP = ytdActual + projectedRemaining;
            const totalUnitsYEP = ytdUnits + projectedRemainingUnits;
            
            let confidence = "Low";
            if (monthsActive >= 3) confidence = "High";
            else if (monthsActive === 2) confidence = "Medium";

            return { name: productName, launchQuarter, ytdActual, projectedRemaining, totalYEP, confidence, growthTrend, monthsActive, remainingMonths, avgMonthly: avgRecentMonthlyRevenue, projectedRemainingUnits, totalUnitsYEP };
        })
        .orderBy('totalYEP', 'desc')
        .value();

    if (charts.yearEndProjection) charts.yearEndProjection.destroy();
    
    charts.yearEndProjection = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: productProjections.map(p => p.name),
            datasets: [
                {
                    label: 'YTD Actual',
                    data: productProjections.map(p => p.ytdActual),
                    backgroundColor: 'rgba(74, 222, 128, 0.8)',
                    order: 2
                },
                {
                    label: 'Projected',
                    data: productProjections.map(p => p.projectedRemaining),
                    backgroundColor: 'rgba(102, 126, 234, 0.7)',
                    borderDash: [5, 5],
                    order: 3
                },
                {
                    label: 'Total 2025 YEP',
                    data: productProjections.map(p => p.totalYEP),
                    type: 'line',
                    borderColor: 'rgba(240, 147, 251, 1)',
                    borderWidth: 3,
                    pointRadius: 5,
                    fill: false,
                    order: 1
                }
            ]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top' },
                tooltip: {
                    callbacks: {
                        label: (context) => `$${context.parsed.x.toLocaleString('en-US', {maximumFractionDigits: 0})}`,
                        afterLabel: (context) => {
                            const proj = productProjections[context.dataIndex];
                            if (context.datasetIndex === 0) { // YTD Actual
                                return [`Launch: ${proj.launchQuarter}`, `Months Active: ${proj.monthsActive}`];
                            } else if (context.datasetIndex === 1) { // Projected
                                return [`Months to Project: ${proj.remainingMonths}`, `Growth Trend: ${(proj.growthTrend * 100).toFixed(1)}%`];
                            } else if (context.datasetIndex === 2) { // Total YEP
                                return [`Total Units YEP: ${Math.round(proj.totalUnitsYEP).toLocaleString()}`, `Confidence: ${proj.confidence}`];
                            }
                            return [];
                        }
                    }
                }
            },
            scales: {
                x: { stacked: true, title: { display: true, text: 'Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } },
                y: { stacked: true, ticks: { autoSkip: false, font: { size: 10 }, callback: function(value) { const label = this.getLabelForValue(value); return label.length > 35 ? label.substring(0, 32) + '...' : label; } } }
            }
        }
    });



    // --- Render Pace to Plan table (if plan exists) ---
(function renderPaceToPlan(){
  const host = document.getElementById('yepPaceToPlan');
  if (!host) return;

  const asOfDate = (function(){
    if (!dashboardData.detailed || dashboardData.detailed.length === 0) return new Date();
    const dates = dashboardData.detailed.map(d => d.posting_date).filter(d => d);
    if (dates.length === 0) return new Date();
    const maxDateStr = _.max(dates);
    return parseYMD(maxDateStr) || new Date();
  })();

  const byProduct = _.chain(dashboardData.detailed)
    .groupBy(d => d.product_name)
    .map((recs, name) => {
      // reuse your existing YEP math (already computed in chart) ‚Äì quick recompute here:
      const monthly = _.chain(recs).groupBy(r => {
        // Handle both string and Date posting_date
        const pd = r.posting_date;
        if (typeof pd === 'string') return pd.substring(0,7);
        if (pd instanceof Date) return `${pd.getFullYear()}-${String(pd.getMonth()+1).padStart(2,'0')}`;
        return 'unknown';
      })
        .map((rows, m) => ({ month:m, revenue: _.sumBy(rows, 'revenue') }))
        .sortBy('month').value();
      const ytdActual = _.sumBy(monthly, 'revenue');
      // ‚Äú(b) last-3-months annualized‚Äù flavor for pace:
      const last3 = monthly.slice(-3);
      const avgRecent = _.meanBy(last3, 'revenue') || 0;
      const yePace = ytdActual + avgRecent * (12 - monthly.length); // simple annualization to year end

      const fyPlan = fyPlanFor('product', name);
      const pace = (fyPlan && fyPlan > 0) ? (yePace / fyPlan) : null;
      return { name, fyPlan, yePace, pace };
    })
    .sortBy(x => x.name)
    .value();

  const rows = byProduct.map(r => `
    <tr>
      <td style="padding:6px 10px;border-bottom:1px solid #333;">${r.name}</td>
      <td style="padding:6px 10px;border-bottom:1px solid #333;text-align:right;">$${r.yePace.toLocaleString()}</td>
    </tr>`).join('');

  host.innerHTML = `
    <div style="margin-top:6px;">Year-End Projection by Product</div>
    <table style="margin-top:6px;border-collapse:collapse;">
      <thead>
        <tr>
          <th style="text-align:left;padding:6px 10px;border-bottom:1px solid #555;">Product</th>
          <th style="text-align:right;padding:6px 10px;border-bottom:1px solid #555;">YEP ($)</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>`;
})();

}

// ---------- Narrative helpers ----------
function movingAvg(arr) {
  if (!arr.length) return 0;
  return _.sum(arr) / arr.length;
}
function pct(a, b) { return b ? (100 * a / b) : 0; }
function nice(num) {
  if (num == null || isNaN(num)) return '‚Äî';
  if (Math.abs(num) >= 1000) return '$' + Math.round(num).toLocaleString();
  if (num >= 100) return '$' + Math.round(num).toLocaleString();
  if (num >= 10) return '$' + num.toFixed(1);
  if (num > 1) return '$' + num.toFixed(2);
  return (typeof num === 'number') ? num.toFixed(2) : String(num);
}

// Summarize one series (arrays of weekly points for doors/opa/rpd with same index order)
// Summarize one series (arrays of weekly points for doors/opa/rpd with same index order)
function summarizeSeries(weeks, doors, opa, rpd) {
  const n = weeks.length;
  if (!n) return { summary: 'No data available for this series.', bullets: [] };

  // --- Coverage trend (Doors) ---
  const firstHalf = Math.max(1, Math.floor(n / 2));
  const earlyDoors = movingAvg(doors.slice(0, firstHalf));
  const lateDoors  = movingAvg(doors.slice(firstHalf));
  const doorsLift  = lateDoors - earlyDoors;
  const doorsLiftPct = pct(doorsLift, (earlyDoors || 1)); // % change from early to late

  // --- Frequency (OPA = paid invoices √∑ doors) ---
  // Treat weeks with OPA > 1.02 as "repeat-order" weeks
  const opaSpikes = opa.filter(v => v > 1.02).length;

  // --- Value per account (RPD = revenue √∑ doors) ---
  const rpdMean = movingAvg(rpd);
  const rpdStd  = Math.sqrt(movingAvg(rpd.map(v => Math.pow(v - rpdMean, 2))));
  const rpdCv   = rpdMean ? (rpdStd / rpdMean) : 0; // volatility via Coefficient of Variation
  const rpdMax  = Math.max(...rpd);
  const rpdMaxWeekIdx = rpd.indexOf(rpdMax);
  const rpdMaxWeek = rpdMaxWeekIdx >= 0 ? weeks[rpdMaxWeekIdx] : '‚Äî';

  // --- Narrative bullets (teach + interpret) ---
  const bullets = [
    // Doors definition + growth
    `Coverage growth: unique active accounts (Doors) increased ${doorsLift >= 0 ? '‚Üë' : '‚Üì'} ${Math.abs(doorsLiftPct).toFixed(0)}% from the first to the last half of the period. ` +
      `Doors = number of accounts with ‚â•1 paid invoice in a week.`,

    // OPA definition + repeat-order characterization
    `Order frequency: repeat-order weeks (Orders Per Account, OPA) > 1.02 occurred ${opaSpikes} of ${n} weeks. ` +
      `OPA = paid invoices √∑ doors; values above 1 indicate some accounts placed multiple orders in the same week.`,

    // RPD definition + central tendency + volatility + max spike
    `Value per account: average revenue per active door (RPD) was ${nice(rpdMean)}. ` +
      `RPD (Revenue Per Door) = total revenue √∑ doors. ` +
      `Volatility (CV) = ${rpdCv.toFixed(2)} ${rpdCv > 0.6 ? '(high variability)' : '(stable)'}; ` +
      `largest per-door revenue spike was ${nice(rpdMax)} in ${rpdMaxWeek}.`
  ];

  // --- One-line summary ---
  const trendPhrase =
    doorsLift > 0 ? `coverage is expanding (more doors each week)` :
    doorsLift < 0 ? `coverage has softened (fewer doors active later)` :
                    `coverage is flat`;

  const freqPhrase =
    opaSpikes > 0 ? `some weeks show accounts placing multiple orders` :
                    `most weeks show only one order per account`;

  const valuePhrase =
    rpdCv > 0.6 ? `average revenue per door (RPD) is volatile, often driven by bulk buys or promotions` :
                  `average revenue per door (RPD) is relatively stable`;

  const summary = `Overall, ${trendPhrase}; ${freqPhrase}; ${valuePhrase}.`;
  return { summary, bullets };
}


// Render the narrative into the box; for distributors/reps show the top 3 by doors
function renderWeeklyNarrative(scope, weeks, dataByKey) {
  const host = document.getElementById('weeklyNarrative');
  if (!host) return;

  const keys = Object.keys(dataByKey);
  if (!keys.length) { host.innerHTML = 'No weekly data.'; return; }

  // Build comparable arrays for each key
  const records = keys.map(k => {
    const arr = dataByKey[k];
    // arrays aligned to "weeks" master list
    const doors = weeks.map(w => (arr.find(x => x.week === w)?.doors) ?? 0);
    const opa   = weeks.map(w => (arr.find(x => x.week === w)?.opa)   ?? 1);
    const rpd   = weeks.map(w => (arr.find(x => x.week === w)?.rpd)   ?? 0);
    const paidInvoices = weeks.map(w => (arr.find(x => x.week === w)?.paidInvoices) ?? 0);
    const doorsSum = _.sum(doors);
    return { key: k, doors, opa, rpd, paidInvoices, doorsSum };
  });

  // For ‚Äúoverall‚Äù just one line
  if (scope === 'overall') {
    const r = records[0];
    const s = summarizeSeries(weeks, r.doors, r.opa, r.rpd);
    host.innerHTML = `
      <div><strong>Interpretation (Overall)</strong></div>
      <div style="margin-top:6px;">${s.summary}</div>
      <ul style="margin:6px 0 0 18px;">
        ${s.bullets.map(b => `<li>${b}</li>`).join('')}
      </ul>`;
    return;
  }

  // Otherwise, pick top 3 by doorsSum
  const top = _.take(_.orderBy(records, ['doorsSum'], ['desc']), 3);

  function labelFor(k) {
    return (scope === 'rep') ? (salesRepMap[String(k)] || 'Unassigned') : k;
    }

  const blocks = top.map(rec => {
    const s = summarizeSeries(weeks, rec.doors, rec.opa, rec.rpd);
    return `
      <div style="margin-top:8px;">
        <div><strong>${labelFor(rec.key)}</strong></div>
        <div>${s.summary}</div>
        <ul style="margin:6px 0 0 18px;">
          ${s.bullets.map(b => `<li>${b}</li>`).join('')}
        </ul>
      </div>`;
  }).join('');

  const title =
    scope === 'distributor' ? 'By Distributor'
  : scope === 'rep'         ? 'By Rep'
  : scope === 'product'     ? 'By Product'
  : 'Overall';
  host.innerHTML = `<div><strong>Interpretation (${title})</strong></div>${blocks}`;
}


function createWeeklyVelocity() {
        const lines = dashboardData.detailed;
        const paid = buildPaidInvoices(lines);

        function seriesByKey(keyGetter, data) {
            const grouped = _.groupBy(
                data,
                inv => `${fmtWeek(d3.timeWeek.floor(inv.posting_date))}::${keyGetter(inv)}`
            );
            const rows = _.map(grouped, (recs, k) => {
                const [week, key] = k.split('::');
                return {
                week,
                key,
                paidInvoices: recs.length,
                doors: calcDoors(recs),
                opa: calcOPA(recs),
                rpd: calcRPD(recs)
                };
            });
            const byKey = _.groupBy(rows, r => r.key);
            for (const k in byKey) byKey[k] = _.sortBy(byKey[k], r => r.week);
            return byKey;
            }



        const scopeEl = document.getElementById('weeklyScope');
        const ctxDoors = document.getElementById('doorsPerWeek').getContext('2d');
        const ctxOPA = document.getElementById('opaPerWeek').getContext('2d');
        const ctxRPD = document.getElementById('rpdPerWeek').getContext('2d');

        function render() {
            const scope = scopeEl.value; // overall | distributor | rep | product

            // Choose dataset to aggregate
            let paidScoped = paid;
            if (scope === 'product') {
                // Launch SKUs only to keep legend readable (filter by UPC, not name)
                paidScoped = paid.filter(inv => innovationUPCs.includes(String(inv.upc_item_code_norm12)));
            }

            // Key getter per scope
            const keyGetter =
                (scope === 'distributor') ? (inv => inv.distributor)
                : (scope === 'rep')         ? (inv => inv.sales_rep || 'Unassigned')
                : (scope === 'product')     ? (inv => inv.product_name)
                :                             (() => 'Overall');

            // Build series
            const dataByKey = seriesByKey(keyGetter, paidScoped);

            // Unified week labels
            const allWeeks = _.uniq(
                _.flatMap(Object.values(dataByKey), arr => arr.map(r => r.week))
            ).sort();

            // Datasets builder
            function dataset(metric) {
                return Object.entries(dataByKey).map(([k, arr]) => ({
                label: (scope === 'rep' ? (salesRepMap[String(k)] || 'Unassigned') : k),
                data: allWeeks.map(w => (arr.find(x => x.week === w)?.[metric]) ?? 0),
                fill: false,
                tension: 0.2
                }));
            }

            // Legend visibility: always on for rep/product; otherwise <=6 series
            const showLegend = (scope === 'rep' || scope === 'product')
                ? true
                : (Object.keys(dataByKey).length <= 6);

            // (Re)draw charts
            if (charts.doorsPerWeek) charts.doorsPerWeek.destroy();
            if (charts.opaPerWeek)   charts.opaPerWeek.destroy();
            if (charts.rpdPerWeek)   charts.rpdPerWeek.destroy();

            charts.doorsPerWeek = new Chart(ctxDoors, {
                type: 'line',
                data: { labels: allWeeks, datasets: dataset('doors') },
                options: { plugins:{ legend:{ display: showLegend } },
                        scales:{ x:{ ticks:{ autoSkip:true, maxTicksLimit:12 } } } }
            });
            charts.opaPerWeek = new Chart(ctxOPA, {
                type: 'line',
                data: { labels: allWeeks, datasets: dataset('opa') },
                options: { plugins:{ legend:{ display: showLegend } },
                        scales:{ x:{ ticks:{ autoSkip:true, maxTicksLimit:12 } } } }
            });
            charts.rpdPerWeek = new Chart(ctxRPD, {
                type: 'line',
                data: { labels: allWeeks, datasets: dataset('rpd') },
                options: { plugins:{ legend:{ display: showLegend } },
                        scales:{ x:{ ticks:{ autoSkip:true, maxTicksLimit:12 } } } }
            });

            // Acceptance check ‚Äî use scoped set
            const weeklySum = _.sumBy(Object.values(dataByKey).flat(), r => r.paidInvoices);
            const ytdPaid   = paidScoped.length;
            console.log(`[Weekly Velocity:${scope}] acceptance ‚Äî weekly sum:`, weeklySum, 'YTD paid:', ytdPaid);

            // Narrative
            renderWeeklyNarrative(scope, allWeeks, dataByKey);
            }


        scopeEl.onchange = render;
        render();
        }

        function createCohortRetention() {
            const paid = buildPaidInvoices(dashboardData.detailed);

            // Build (account, product) sequences
            const byAcctProd = _.groupBy(paid, inv => `${inv.canonical_code}::${inv.product_name}`);
            const firsts = [];
            for (const key in byAcctProd) {
                const arr = _.sortBy(byAcctProd[key], inv => inv.posting_date);
                const first = arr[0];
                const second = arr[1] || null;
                firsts.push({
                product: first.product_name,
                cohortMonth: d3.timeFormat('%Y-%m')(d3.timeMonth.floor(first.posting_date)),
                has2nd30: !!(second && (second.posting_date - first.posting_date) <= 30*864e5),
                has2nd60: !!(second && (second.posting_date - first.posting_date) <= 60*864e5),
                has2nd90: !!(second && (second.posting_date - first.posting_date) <= 90*864e5)
                });
            }

            // Aggregate by cohort month (overall)
            const byCohort = _.groupBy(firsts, r => r.cohortMonth);
            const months = Object.keys(byCohort).sort();
            const pct = (num, den) => den ? (100*num/den) : 0;

            const ds30 = months.map(m => pct(_.sumBy(byCohort[m], r => r.has2nd30 ? 1 : 0), byCohort[m].length));
            const ds60 = months.map(m => pct(_.sumBy(byCohort[m], r => r.has2nd60 ? 1 : 0), byCohort[m].length));
            const ds90 = months.map(m => pct(_.sumBy(byCohort[m], r => r.has2nd90 ? 1 : 0), byCohort[m].length));

            // Monotonicity (‚â§30 ‚â• ‚â§60 ‚â• ‚â§90) is naturally satisfied; no smoothing needed.

            if (charts.cohortRetention) charts.cohortRetention.destroy();
            const ctx = document.getElementById('cohortRetention').getContext('2d');
            charts.cohortRetention = new Chart(ctx, {
                type: 'line',
                data: {
                labels: months,
                datasets: [
                    { label: '‚â§30d', data: ds30, tension:0.2, fill:false },
                    { label: '‚â§60d', data: ds60, tension:0.2, fill:false },
                    { label: '‚â§90d', data: ds90, tension:0.2, fill:false }
                ]
                },
                options: {
                responsive: true,
                plugins: {
                    tooltip: {
                    callbacks: {
                        afterLabel: (ctx) => {
                        const m = months[ctx.dataIndex];
                        const den = byCohort[m].length;
                        const n30 = _.sumBy(byCohort[m], r => r.has2nd30?1:0);
                        const n60 = _.sumBy(byCohort[m], r => r.has2nd60?1:0);
                        const n90 = _.sumBy(byCohort[m], r => r.has2nd90?1:0);
                        return ` n30=${n30}/${den}, n60=${n60}/${den}, n90=${n90}/${den}`;
                        }
                    }
                    },
                    legend: { position: 'top' }
                },
                scales:{ y:{ ticks:{ callback: v => v+'%' } } }
                }
            });
            renderCohortNarrative(months, byCohort);

            }

            function renderCohortNarrative(months, byCohort) {
                const host = document.getElementById('cohortNarrative');
                if (!host) return;

                if (!months.length) {
                    host.innerHTML = 'No cohort data available.';
                    return;
                }

                // Compute overall averages across cohorts (percentages)
                const avgPct = (num, den) => den ? (100 * num / den) : 0;
                const asPct = v => (isFinite(v) ? v.toFixed(0) + '%' : '‚Äî');

                const avg30 = _.mean(months.map(m => avgPct(_.sumBy(byCohort[m], r => r.has2nd30 ? 1 : 0), byCohort[m].length)));
                const avg60 = _.mean(months.map(m => avgPct(_.sumBy(byCohort[m], r => r.has2nd60 ? 1 : 0), byCohort[m].length)));
                const avg90 = _.mean(months.map(m => avgPct(_.sumBy(byCohort[m], r => r.has2nd90 ? 1 : 0), byCohort[m].length)));

                const latestMonth = months[months.length - 1];

                host.innerHTML = `
                    <div><strong>Interpretation (Cohort Retention)</strong></div>
                    <div style="margin-top:6px;">
                    Each cohort groups accounts by their <em>first purchase month</em>, and we track whether they placed a
                    <strong>second order</strong> within 30, 60, or 90 days.
                    </div>
                    <ul style="margin:6px 0 0 18px;">
                    <li><strong>Stickiness at 30 days:</strong> On average, ${asPct(avg30)} of new accounts reorder within the first month.</li>
                    <li><strong>Momentum at 60 days:</strong> ${asPct(avg60)} reorder by two months.</li>
                    <li><strong>Longer-term retention (90 days):</strong> ${asPct(avg90)} reorder within three months.</li>
                    <li>Latest cohort (<strong>${latestMonth}</strong>) is being tracked in real time; its curve will extend as weeks pass.</li>
                    </ul>
                    <div style="margin-top:6px;">
                    Cohort curves should slope downward or stay flat (monotonic). Higher early percentages mean accounts become loyal faster.
                    </div>
                `;
                }






        async function runDataDiagnostics() {
        console.log("%c--- STARTING DATA DIAGNOSTICS on innovations_transactions_2025.csv ---", "color: yellow; font-size: 14px;");
        try {
            const fileContent = await fetch('data/innovations_transactions_2025.csv').then(res => res.text());
            const data = Papa.parse(fileContent, { header: true, dynamicTyping: true, skipEmptyLines: true }).data;

            console.log(`Total rows loaded for diagnostics: ${data.length}`);

            // Test 1: Check the 'year' column directly for any non-2025 values.
            const wrongYearRows = data.filter(d => d.year !== 2025);
            if (wrongYearRows.length > 0) {
                console.warn("DIAGNOSTIC FAILED: Found rows where the 'year' column is NOT 2025.");
                console.table(wrongYearRows);
            } else {
                console.log("DIAGNOSTIC PASSED: The 'year' column contains only 2025 values.");
            }

            // Test 2: Check how JavaScript's Date parser interprets the 'posting_date' column.
            const misInterpretedRows = data.filter(d => {
                if (!d.posting_date) return false;
                const parsedYear = new Date(d.posting_date).getFullYear();
                return parsedYear !== 2025;
            });

            if (misInterpretedRows.length > 0) {
                console.warn("DIAGNOSTIC FAILED: Found rows where JavaScript is misinterpreting 'posting_date' as a non-2025 year.");
                console.table(misInterpretedRows);
            } else {
                console.log("DIAGNOSTIC PASSED: JavaScript is correctly interpreting all 'posting_date' values as 2025.");
            }

        } catch (error) {
            console.error("Could not run diagnostics. Failed to load or parse innovations_transactions_2025.csv.", error);
        }
        console.log("%c--- DATA DIAGNOSTICS COMPLETE ---", "color: yellow; font-size: 14px;");
    }

    function createAccountSummaryData() {
        const data2025 = dashboardData.detailed;
        // Use the latest transaction date from actual data instead of hardcoded date
        const today = data2025.length > 0
            ? _.maxBy(data2025.map(d => parseYMD(d.posting_date)).filter(d => d), d => d.getTime()) || new Date()
            : new Date();

        // Step 1: Group all transaction lines by invoice to get invoice-level data
        const invoices = _.chain(data2025)
            .groupBy(d => `${d.canonical_code}-${d.distributor}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                canonical_code: lines[0].canonical_code,
                distributor: lines[0].distributor,
                sales_rep: lines[0].sales_rep,
                posting_date: parseYMD(lines[0].posting_date),
                revenue: _.sumBy(lines, 'revenue'),
                units: _.sumBy(lines, 'quantity'),
                skus: _.uniq(lines.map(l => l.product_name))
            }))
            .value();

        // Step 2: Group all paid invoices by account to build the final summary
        const accountSummary = _.chain(invoices)
            .filter(inv => inv.revenue > 0) // Use only paid invoices for metrics
            .groupBy('canonical_code')
            .map((accountInvoices, accountCode) => {
                const sortedInvoices = _.orderBy(accountInvoices, 'posting_date', 'asc');
                const firstPurchase = sortedInvoices[0].posting_date;
                const lastPurchase = sortedInvoices[sortedInvoices.length - 1].posting_date;
                const daysSinceLast = Math.round((today - lastPurchase) / (1000 * 60 * 60 * 24));
                
                const revenueYTD = _.sumBy(sortedInvoices, 'revenue');
                const unitsYTD = _.sumBy(sortedInvoices, 'units');
                const paidInvoices = sortedInvoices.length;
                const aov = revenueYTD / paidInvoices;

                let status = "Active";
                if (daysSinceLast > 90) status = "Dormant";
                else if (daysSinceLast > 60) status = "At-Risk";
                else if (paidInvoices === 1) status = "New";

                const churnData = dashboardData.churnDetails?.[String(accountCode)] ?? null;
                return {
                    accountCode,
                    distributors: _.uniq(sortedInvoices.map(i => i.distributor)).join(', '),
                    salesRep: _.uniq(sortedInvoices.map(i => i.sales_rep)).join(', '),
                    revenueYTD,
                    unitsYTD,
                    paidInvoices,
                    aov,
                    skuBreadth: _.uniq(_.flatMap(sortedInvoices, 'skus')).length,
                    firstPurchase: firstPurchase.toLocaleDateString('en-US'),
                    lastPurchase: lastPurchase.toLocaleDateString('en-US'),
                    daysSinceLast,
                    status,
                    risk_prob_60d: dashboardData.riskByAccount?.[String(accountCode)] ?? null,
                    velocity_trend: churnData?.velocity_trend ?? null,
                    days_into_cycle: churnData?.days_into_cycle ?? null,
                    median_interval: churnData?.median_interval ?? null
                };
            })
            .orderBy('revenueYTD', 'desc')
            .value();
            
        return accountSummary;
    }
    
    function updateProductDeepDive(selectedProduct) {
        if (!selectedProduct) return;

        // Filter by UPC instead of product name to handle name variations
        const productUPC = productNameToUPC[selectedProduct];
        if (!productUPC) {
            console.warn(`No UPC found for product: ${selectedProduct}`);
            return;
        }
        const productData = dashboardData.detailed.filter(d => String(d.upc_item_code_norm12) === productUPC);

        const invoices = _.chain(productData)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                canonical_code: lines[0].canonical_code, // Keep track of the account for the paid accounts count
                totalRevenue: _.sumBy(lines, 'revenue'),
                totalUnits: _.sumBy(lines, 'quantity')
            }))
            .value();

        const paidInvoices = invoices.filter(inv => inv.totalRevenue > 0);
        
        const ytdRevenue = _.sumBy(paidInvoices, 'totalRevenue');
        const ytdUnits = _.sumBy(paidInvoices, 'totalUnits');
        const paidInvoiceCount = paidInvoices.length;
        const aov = paidInvoiceCount > 0 ? ytdRevenue / paidInvoiceCount : 0;
        const asp = ytdUnits > 0 ? ytdRevenue / ytdUnits : 0;

        // --- THIS IS THE FIX for Active Accounts ---
        // It now correctly counts unique accounts from the list of PAID invoices.
        const activeAccounts = _.uniqBy(paidInvoices, 'canonical_code').length;

        const kpis = [
            { label: 'YTD Revenue', value: `$${ytdRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})}` },
            { label: 'YTD Units', value: ytdUnits.toLocaleString() },
            { label: 'Paid Invoices', value: paidInvoiceCount.toLocaleString() },
            { label: 'AOV (Invoice)', value: `$${aov.toFixed(2)}` },
            { label: 'ASP', value: `$${asp.toFixed(2)}` },
            { label: 'Active Accounts', value: activeAccounts.toLocaleString() } // Now correct
        ];

        const grid = document.getElementById('productKpiGrid');
        grid.innerHTML = '';
        kpis.forEach(kpi => {
            const card = document.createElement('div');
            card.className = 'kpi-card';
            card.innerHTML = `<div class="label">${kpi.label}</div><div class="value">${kpi.value}</div>`;
            grid.appendChild(card);
        });

        // Call the chart and the new table function
        createDistributorMixForProduct(productData);
        createAccountsForProductTable(productData);
    }


    function createDistributorMixForProduct(productData) {
        const ctx = document.getElementById('distributorMixForProductChart').getContext('2d');
        
        const distributorRevenue = _.chain(productData)
            .groupBy('distributor')
            .map((records, distName) => ({
                distributor: distName,
                revenue: _.sumBy(records, 'revenue')
            }))
            .orderBy('revenue', 'desc')
            .slice(0, 10) // Show top 10 distributors
            .value();

        if (charts.distributorMix) charts.distributorMix.destroy();

        charts.distributorMix = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: distributorRevenue.map(d => d.distributor),
                datasets: [{
                    label: 'Revenue',
                    data: distributorRevenue.map(d => d.revenue),
                    backgroundColor: '#667eea'
                }]
            },
            options: {
                indexAxis: 'y', // Horizontal bar chart
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } }
                }
            }
        });
    }

    function createAccountsForProductTable(productData) {
        const container = document.getElementById('accountsForProductTable');
        if (!container) return;

        // Use the latest transaction date from actual data instead of hardcoded date
        const today = productData.length > 0
            ? _.maxBy(productData.map(d => parseYMD(d.posting_date)).filter(d => d), d => d.getTime()) || new Date()
            : new Date();

        // Step 1: Find and sort all distributors by their revenue for this product
        const distributorsByRevenue = _.chain(productData)
            .groupBy('distributor')
            .map((records, distName) => ({
                distributor: distName,
                revenue: _.sumBy(records, 'revenue')
            }))
            .orderBy('revenue', 'desc')
            .map('distributor')
            .value();

        let finalHtml = '';

        // Step 2: Loop through each distributor
        distributorsByRevenue.forEach(distName => {
            // Step 3: For each distributor, find and list their accounts
            const distributorSpecificData = productData.filter(d => d.distributor === distName);

            const invoices = _.chain(distributorSpecificData)
                .groupBy(d => `${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
                .map(lines => ({
                    canonical_code: lines[0].canonical_code,
                    posting_date: parseYMD(lines[0].posting_date),
                    revenue: _.sumBy(lines, 'revenue'),
                    units: _.sumBy(lines, 'quantity'),
                }))
                .filter(inv => inv.revenue > 0)
                .value();

            const accountData = _.chain(invoices)
                .groupBy('canonical_code')
                .map((acctInvoices, accountCode) => {
                    const revenueYTD = _.sumBy(acctInvoices, 'revenue');
                    const unitsYTD = _.sumBy(acctInvoices, 'units');
                    const lastPurchase = _.maxBy(acctInvoices, 'posting_date').posting_date;
                    const daysSinceLast = Math.round((today - lastPurchase) / (1000 * 60 * 60 * 24));
                    const churnData = dashboardData.churnDetails?.[String(accountCode)] ?? null;
                    return {
                     accountCode, revenueYTD, unitsYTD,
                     paidInvoices: acctInvoices.length,
                     aov: revenueYTD / acctInvoices.length,
                     lastPurchase: lastPurchase.toLocaleDateString('en-US'),
                     daysSinceLast,
                     risk_prob_60d: dashboardData.riskByAccount?.[String(accountCode)] ?? null,
                     velocity_trend: churnData?.velocity_trend ?? null,
                     days_into_cycle: churnData?.days_into_cycle ?? null,
                     median_interval: churnData?.median_interval ?? null
                   };
                })
                .orderBy('revenueYTD', 'desc')
                .value();

            // Step 4: Build the HTML for this distributor's section
            finalHtml += `
                <h4 style="color: #e0e0e0; margin-top: 25px; margin-bottom: 10px; border-bottom: 1px solid #667eea; padding-bottom: 5px;">
                    ${distName}
                </h4>
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th>Account</th>
                            <th>Revenue YTD</th>
                            <th>Paid Invoices</th>
                            <th>AOV (Invoice)</th>
                            <th>Last Purchase</th>
                            <th>Days Since Last</th>
                            <th>Velocity Trend</th>
                            <th>At-Risk Prob (‚â§60d)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${accountData.map(acc => `
                            <tr>
                                <td>${acc.accountCode}</td>
                                <td>$${acc.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                                <td>${acc.paidInvoices}</td>
                                <td>$${acc.aov.toFixed(2)}</td>
                                <td>${acc.lastPurchase}</td>
                                <td>${acc.daysSinceLast}</td>
                                <td>${formatVelocityTrend(acc.velocity_trend)}</td>
                                <td>${formatRiskBadge(acc.risk_prob_60d)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        });

        // Step 5: Render the complete HTML to the page
        container.innerHTML = finalHtml;
    }

    function formatRiskBadge(v) {
        if (v == null || isNaN(v)) return '‚Äî';
        const pct = (v * 100).toFixed(0) + '%';
        const cls = v >= 0.6 ? 'badge-red' : v >= 0.3 ? 'badge-amber' : 'badge-green';
        return `<span class="${cls}">${pct}</span>`;
    }

    function formatVelocityTrend(v) {
        if (v == null || isNaN(v)) return '‚Äî';

        // Velocity trend interpretation:
        // > 1.5 = Accelerating significantly (ordering 50%+ faster)
        // 1.2-1.5 = Accelerating moderately
        // 0.8-1.2 = Stable
        // 0.5-0.8 = Decelerating moderately
        // < 0.5 = Decelerating significantly (ordering 50%+ slower)

        let icon, text, cls;
        if (v >= 1.5) {
            icon = 'üü¢‚¨Ü';
            text = 'Accelerating';
            cls = 'badge-green';
        } else if (v >= 1.2) {
            icon = 'üü¢‚Üó';
            text = 'Faster';
            cls = 'badge-green';
        } else if (v >= 0.8) {
            icon = '‚ö™‚û°';
            text = 'Stable';
            cls = 'badge-gray';
        } else if (v >= 0.5) {
            icon = 'üü°‚Üò';
            text = 'Slower';
            cls = 'badge-amber';
        } else {
            icon = 'üî¥‚¨á';
            text = 'Decelerating';
            cls = 'badge-red';
        }

        return `<span class="${cls}" title="Velocity: ${v.toFixed(2)}x">${icon} ${text}</span>`;
    }


function populateTables() {
    // --- Get Master Account Data (used for the accounts table) ---
    const accountData = createAccountSummaryData();

            // --- 1. Top 20 Account Penetration Table ---
            const accountPenetrationTable = document.getElementById('accountPenetrationTable');
        if (accountPenetrationTable) {
            const top20Accounts = accountData.slice(0, 20);
            accountPenetrationTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Account</th>
                        <th>Revenue YTD</th>
                        <th>SKU Breadth</th>
                        <th>Penetration Score</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    ${top20Accounts.map(acc => `
                        <tr>
                            <td>${acc.accountCode}</td>
                            <td>$${acc.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                            <td>${acc.skuBreadth} of 8</td>
                            <td>${((acc.skuBreadth / 8) * 100).toFixed(0)}%</td>
                            <td>${acc.status}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
        }

    // --- 1. Distributor Performance Matrix ---
    const distributorTable = document.getElementById('distributorTable');
    if (distributorTable) {
        // Build all invoices (both positive and negative)
        const allInvoices = _.chain(dashboardData.detailed)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                distributor: lines[0].distributor,
                canonical_code: lines[0].canonical_code,
                posting_date: parseYMD(lines[0].posting_date),
                revenue: _.sumBy(lines, 'revenue'),
                units: _.sumBy(lines, 'quantity'),
                skus: _.uniq(lines.map(l => l.product_name))
            }))
            .value();

        // Separate paid invoices for metrics
        const paidInvoices = allInvoices.filter(inv => inv.revenue > 0);

        const distributorData = _.chain(paidInvoices)
            .groupBy('distributor')
            .map((distInvoices, distName) => {
                const revenueYTD = _.sumBy(distInvoices, 'revenue');
                const unitsYTD = _.sumBy(distInvoices, 'units');
                const paidInvoiceCount = distInvoices.length;
                const aov = paidInvoiceCount > 0 ? revenueYTD / paidInvoiceCount : 0;
                const activeAccounts = _.uniqBy(distInvoices, 'canonical_code').length;
                const skuBreadthByAccount = _.chain(distInvoices).groupBy('canonical_code').map(acctInvoices => _.uniq(_.flatMap(acctInvoices, 'skus')).length).mean().value();
                const accountsWithReorder = _.chain(distInvoices).groupBy('canonical_code').map(acctInvoices => {
                    if (acctInvoices.length < 2) return 0;
                    const sortedDates = _.orderBy(acctInvoices, 'posting_date', 'asc');
                    for (let i = 1; i < sortedDates.length; i++) {
                        if ((sortedDates[i].posting_date - sortedDates[i-1].posting_date) / (1000 * 60 * 60 * 24) <= 60) return 1;
                    }
                    return 0;
                }).sum().value();
                const reorderRate = activeAccounts > 0 ? (accountsWithReorder / activeAccounts) * 100 : 0;

                // Calculate returns/chargebacks (negative revenue) for this distributor
                const distReturns = _.sumBy(
                    allInvoices.filter(inv => inv.distributor === distName && inv.revenue < 0),
                    'revenue'
                );
                const netRevenue = revenueYTD + distReturns; // distReturns is already negative

                return {
                    distributor: distName,
                    revenueYTD,
                    returns: distReturns,
                    netRevenue,
                    unitsYTD,
                    paidInvoices: paidInvoiceCount,
                    aov,
                    activeAccounts,
                    skuBreadth: skuBreadthByAccount,
                    reorderRate
                };
            })
            .orderBy('revenueYTD', 'desc')
            .value();
        
        distributorTable.innerHTML = `
            <thead>
                <tr>
                    <th>Distributor</th>
                    <th>Revenue YTD</th>
                    <th>Returns/Chargebacks</th>
                    <th>Net Revenue</th>
                    <th>Units YTD</th>
                    <th>Paid Invoices</th>
                    <th>AOV (Invoice)</th>
                    <th>Active Accounts</th>
                    <th>Avg. SKU Breadth</th>
                    <th>Reorder Rate (‚â§60d)</th>
                </tr>
            </thead>
            <tbody>
                ${distributorData.map(dist => `
                    <tr>
                        <td>${dist.distributor}</td>
                        <td>$${dist.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td style="color: ${dist.returns < 0 ? '#ef4444' : '#888'};">${dist.returns < 0 ? '-' : ''}$${Math.abs(dist.returns).toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>$${dist.netRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>${dist.unitsYTD.toLocaleString()}</td>
                        <td>${dist.paidInvoices.toLocaleString()}</td>
                        <td>$${dist.aov.toFixed(2)}</td>
                        <td>${dist.activeAccounts.toLocaleString()}</td>
                        <td>${dist.skuBreadth.toFixed(1)}</td>
                        <td>${dist.reorderRate.toFixed(1)}%</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
    }

    // --- 2. All Accounts Table ---
    const allAccountsTable = document.getElementById('allAccountsTable');
    if (allAccountsTable) {
        allAccountsTable.innerHTML = `
            <thead>
                <tr>
                    <th>Account</th>
                    <th>Status</th>
                    <th>Revenue YTD</th>
                    <th>Paid Invoices</th>
                    <th>AOV (Invoice)</th>
                    <th>SKU Breadth</th>
                    <th>Days Since Last</th>
                    <th>First Purchase</th>
                    <th>Velocity Trend</th>
                    <th>At-Risk Prob (‚â§60d)</th>
                </tr>
            </thead>
            <tbody>
                ${accountData.map(acc => `
                    <tr>
                        <td>${acc.accountCode}</td>
                        <td>${acc.status}</td>
                        <td>$${acc.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>${acc.paidInvoices}</td>
                        <td>$${acc.aov.toFixed(2)}</td>
                        <td>${acc.skuBreadth}</td>
                        <td>${acc.daysSinceLast}</td>
                        <td>${acc.firstPurchase}</td>
                        <td>${formatVelocityTrend(acc.velocity_trend)}</td>
                        <td>${formatRiskBadge(acc.risk_prob_60d)}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
    }
        
    // --- 3. Sales Rep Leaderboard ---
    const repLeaderboard = document.getElementById('repLeaderboard');
    if (repLeaderboard) {
        // Build all invoices (including returns/chargebacks with negative revenue)
        const allInvoices = _.chain(dashboardData.detailed)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                sales_rep: lines[0].sales_rep,
                canonical_code: lines[0].canonical_code,
                posting_date: parseYMD(lines[0].posting_date),
                revenue: _.sumBy(lines, 'revenue'),
                units: _.sumBy(lines, 'quantity')
            }))
            .value();

        const repData = _.chain(allInvoices)
            .groupBy('sales_rep')
            .map((repInvoices, repId) => {
                // Net revenue includes returns/chargebacks (negative values deducted automatically)
                const revenueYTD = _.sumBy(repInvoices, 'revenue');
                const unitsYTD = _.sumBy(repInvoices, 'units');

                // Count-based metrics use only paid invoices (revenue > 0)
                const paidInvoices = repInvoices.filter(inv => inv.revenue > 0);
                const paidInvoiceCount = paidInvoices.length;
                const paidRevenue = _.sumBy(paidInvoices, 'revenue');
                const aov = paidInvoiceCount > 0 ? paidRevenue / paidInvoiceCount : 0;
                const asp = unitsYTD > 0 ? revenueYTD / unitsYTD : 0;
                const activeAccounts = _.uniqBy(paidInvoices, 'canonical_code').length;
                const accountsWithReorder = _.chain(paidInvoices).groupBy('canonical_code').map(acctInvoices => {
                    if (acctInvoices.length < 2) return 0;
                    const sortedDates = _.orderBy(acctInvoices, 'posting_date', 'asc');
                    for (let i = 1; i < sortedDates.length; i++) {
                        if ((sortedDates[i].posting_date - sortedDates[i-1].posting_date) / (1000 * 60 * 60 * 24) <= 60) return 1;
                    }
                    return 0;
                }).sum().value();
                const reorderRate = activeAccounts > 0 ? (accountsWithReorder / activeAccounts) * 100 : 0;
                return { repId, revenueYTD, unitsYTD, paidInvoices: paidInvoiceCount, aov, asp, activeAccounts, reorderRate };
            })
            .value();
        
        const adminRepIds = ['-1', '59', '61', '62', '63', '64', '81', '83', '95'];
        const fieldReps = _.orderBy(repData.filter(r => !adminRepIds.includes(String(r.repId))), 'revenueYTD', 'desc');

        repLeaderboard.innerHTML = `
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Sales Rep</th>
                    <th>Revenue YTD</th>
                    <th>Paid Invoices</th>
                    <th>AOV (Invoice)</th>
                    <th>ASP</th>
                    <th>Active Accounts</th>
                    <th>Reorder Rate (‚â§60d)</th>
                </tr>
            </thead>
            <tbody>
                ${fieldReps.map((rep, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${salesRepMap[rep.repId] || `ID: ${rep.repId}`}</td>
                        <td>$${rep.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>${rep.paidInvoices.toLocaleString()}</td>
                        <td>$${rep.aov.toFixed(2)}</td>
                        <td>$${rep.asp.toFixed(2)}</td>
                        <td>${rep.activeAccounts.toLocaleString()}</td>
                        <td>${rep.reorderRate.toFixed(1)}%</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
    }
}
        
        function generateAdvancedInsights() {
            const insights = document.getElementById('advancedInsights');

            // Keep total revenue for the other insights
            const totalRevenue = _.sumBy(dashboardData.monthly, 'revenue');

            // ‚úÖ Compute AOV from PAID INVOICES (invoice-level), not line items
            const paidInvoices = buildPaidInvoices(dashboardData.detailed); // returns only rev>0 invoices
            const invoiceAOV = paidInvoices.length
                ? _.sumBy(paidInvoices, i => Number(i.revenue) || 0) / paidInvoices.length
                : 0;

            const topProduct = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .mapValues(records => _.sumBy(records, 'revenue'))
                .toPairs()
                .orderBy([1], ['desc'])
                .first()
                .value() || ['N/A', 0];

            // Calculate distributor market share - filter to positive revenue only (paid invoices, exclude returns)
            const paidDistributor = dashboardData.distributor.filter(r => r.revenue_ytd > 0);
            const totalDistributorRevenue = _.sumBy(paidDistributor, 'revenue_ytd');
            const topDistributor = _.chain(paidDistributor)
                .groupBy('distributor')
                .mapValues(records => _.sumBy(records, 'revenue_ytd'))
                .toPairs()
                .orderBy([1], ['desc'])
                .first()
                .value() || ['N/A', 0];

            // Calculate cross-sell opportunity based on multi-product vs single-product account performance
            const accountsByCode = _.chain(dashboardData.accounts)
                .groupBy('canonical_code')
                .map((records, code) => ({
                    account: code,
                    revenue: _.sumBy(records, 'revenue_ytd'),
                    productCount: _.uniq(records.map(r => r.product_name)).length
                }))
                .value();

            const multiSKUAccounts = accountsByCode.filter(a => a.productCount > 1);
            const singleSKUAccounts = accountsByCode.filter(a => a.productCount === 1);

            const totalAccounts = accountsByCode.length;
            const multiSKURate = totalAccounts ? ((multiSKUAccounts.length / totalAccounts) * 100).toFixed(1) : '0.0';

            // Calculate uplift potential: if single-product accounts spent like multi-product accounts
            const avgMultiSKURevenue = multiSKUAccounts.length > 0
                ? _.sumBy(multiSKUAccounts, 'revenue') / multiSKUAccounts.length
                : 0;
            const currentSingleSKURevenue = _.sumBy(singleSKUAccounts, 'revenue');
            const potentialUplift = (avgMultiSKURevenue * singleSKUAccounts.length) - currentSingleSKURevenue;

            insights.innerHTML = `
                <div class="insight-item">
                <strong>üéØ Top Performer:</strong> ${topProduct[0]} leads with $${topProduct[1].toLocaleString('en-US', {maximumFractionDigits: 0})} in revenue,
                representing ${((topProduct[1] / totalRevenue) * 100).toFixed(1)}% of total launch revenue.
                </div>
                <div class="insight-item">
                <strong>üè¢ Distribution Excellence:</strong> ${topDistributor[0]} dominates with ${((topDistributor[1] / totalDistributorRevenue) * 100).toFixed(1)}% of distributor revenue, suggesting strong channel alignment.
                </div>
                <div class="insight-item">
                <strong>üîÑ Cross-Sell Opportunity:</strong> ${(100 - parseFloat(multiSKURate)).toFixed(1)}% of accounts carry only a single product,
                representing expansion potential worth $${potentialUplift.toLocaleString('en-US', {maximumFractionDigits: 0})}.
                </div>
                <div class="insight-item">
                <strong>üí∞ Value Optimization:</strong> Average order value (invoice) is $${invoiceAOV.toFixed(2)}.
                </div>
            `;

            createHeatmap();
        }

        
        function createHeatmap() {
            const heatmapContainer = document.getElementById('heatmap');
            heatmapContainer.innerHTML = ''; // Clear previous
            
            const heatmapData = _.chain(dashboardData.distributor)
                .groupBy('distributor')
                .mapValues(distRecords => 
                    _.chain(distRecords)
                        .groupBy('product_name')
                        .mapValues(records => _.sumBy(records, 'revenue_ytd'))
                        .value()
                )
                .value();
            
                const distributors = Object.keys(heatmapData);
            const products = newProductsList.slice(0, 6);
            
            const width = 800;
            const height = 300;
            const margin = { top: 100, right: 50, bottom: 50, left: 200 };
            
            const svg = d3.select(heatmapContainer)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const xScale = d3.scaleBand()
                .domain(products)
                .range([margin.left, width - margin.right])
                .padding(0.05);
            
            const yScale = d3.scaleBand()
                .domain(distributors)
                .range([margin.top, height - margin.bottom])
                .padding(0.05);
            
            const maxValue = d3.max(distributors.flatMap(d => products.map(p => heatmapData[d]?.[p] || 0)));
            
            const colorScale = d3.scaleSequential()
                .interpolator(d3.interpolatePlasma)
                .domain([0, maxValue]);
            
            distributors.forEach(distributor => {
                products.forEach(product => {
                    const value = heatmapData[distributor]?.[product] || 0;
                    svg.append('rect')
                        .attr('x', xScale(product))
                        .attr('y', yScale(distributor))
                        .attr('width', xScale.bandwidth())
                        .attr('height', yScale.bandwidth())
                        .attr('fill', colorScale(value))
                        .attr('stroke', 'rgba(255,255,255,0.1)')
                        .append('title')
                        .text(`${distributor} - ${product}: $${value.toLocaleString()}`);
                });
            });
            
            svg.append('g')
                .attr('transform', `translate(0,${margin.top})`)
                .selectAll('text')
                .data(products)
                .enter().append('text')
                .attr('x', d => xScale(d) + xScale.bandwidth() / 2)
                .attr('y', -10)
                .attr('text-anchor', 'end')
                .attr('transform', d => `rotate(-45, ${xScale(d) + xScale.bandwidth() / 2}, -10)`)
                .style('fill', '#e0e0e0')
                .style('font-size', '10px')
                .text(d => d.length > 20 ? d.substring(0, 17) + '...' : d);
            
            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .selectAll('text')
                .data(distributors)
                .enter().append('text')
                .attr('x', -10)
                .attr('y', d => yScale(d) + yScale.bandwidth() / 2)
                .attr('text-anchor', 'end')
                .attr('alignment-baseline', 'middle')
                .style('fill', '#e0e0e0')
                .style('font-size', '11px')
                .text(d => d);
        }

        // Tab switching function
        function switchTab(event, tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            Object.values(charts).forEach(chart => {
                if (chart) chart.resize();
            });
        }
        
        // Initialize dashboard when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
        });
    </script>
</body>
</html><!-- Cache bust: Thu Nov 13 13:08:30 PST 2025 -->
