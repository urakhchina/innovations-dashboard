<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 New Product Launch Analytics Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .dashboard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .dashboard-header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 50%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            font-weight: 800;
            color: #fff;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }
        
        .dashboard-header .subtitle {
            font-size: 1.2em;
            color: rgba(255,255,255,0.9);
            position: relative;
            z-index: 1;
        }
        
        .new-products-banner {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(240,147,251,0.3);
        }
        
        .new-products-banner h2 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.8em;
        }
        
        .product-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .product-pill {
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 25px;
            color: #fff;
            font-weight: 600;
            font-size: 0.9em;
            border: 1px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }
        
        .product-pill:hover {
            transform: translateY(-2px);
            background: rgba(255,255,255,0.3);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .product-pill .quarter {
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
            font-size: 0.85em;
        }
        
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .kpi-card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }
        
        .kpi-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102,126,234,0.3);
            background: rgba(255,255,255,0.08);
        }
        
        .kpi-card .label {
            font-size: 0.9em;
            color: #a0a0a0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .kpi-card .value {
            font-size: 2em;
            font-weight: 700;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .kpi-card .change {
            font-size: 0.9em;
            color: #4ade80;
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .chart-container:hover {
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.08);
        }
        
        .chart-container h3 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chart-container canvas {
            max-height: 300px;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .table-container {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 30px;
            overflow-x: auto;
        }
        
        .table-container h3 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: rgba(102,126,234,0.2);
        }
        
        th {
            padding: 12px;
            text-align: left;
            color: #fff;
            font-weight: 600;
            border-bottom: 2px solid rgba(102,126,234,0.5);
        }
        
        td {
            padding: 10px 12px;
            color: #e0e0e0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        tbody tr:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .heatmap-container {
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .insights-section {
            background: linear-gradient(135deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 30px;
        }
        
        .insights-section h3 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .insight-item {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }
        
        .insight-item strong {
            color: #667eea;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102,126,234,0.3);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .tab-navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 12px 24px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .tab-button:hover {
            background: rgba(102,126,234,0.2);
            transform: translateY(-2px);
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            border-color: transparent;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="dashboard-header">
        <h1>üöÄ 2025 New Product Launch Analytics Dashboard</h1>
        <div class="subtitle">Executive Performance Metrics & Advanced Analytics</div>
    </div>
    
    <div class="new-products-banner">
        <h2>üì¶ New Product Launches</h2>
        <div class="product-pills" id="productPills"></div>
    </div>
    
    <div class="kpi-grid" id="kpiGrid"></div>
    
    <div class="tab-navigation">
        <button class="tab-button active" onclick="switchTab(event, 'overview')">üìä Overview</button>
        <button class="tab-button" onclick="switchTab(event, 'temporal')">üìà Temporal Analysis</button>
        <button class="tab-button" onclick="switchTab(event, 'distributor')">üè¢ Distributor Analytics</button>
        <button class="tab-button" onclick="switchTab(event, 'salesrep')">üë§ Sales Rep Performance</button>
        <button class="tab-button" onclick="switchTab(event, 'accounts')">üõí Account Analytics</button>
        <button class="tab-button" onclick="switchTab(event, 'product')">üì¶ Product Deep Dive</button>
        <button class="tab-button" onclick="switchTab(event, 'advanced')">üß≠ Advanced Analytics</button>
    </div>
    
    <div id="overview" class="tab-content active">
        <div class="analytics-grid">
            <div class="chart-container">
                <h3>üí∞ Revenue by Product</h3>
                <canvas id="revenueByProduct"></canvas>
            </div>
            <div class="chart-container">
                <h3>üì¶ Units Sold by Product</h3>
                <canvas id="unitsByProduct"></canvas>
            </div>
            <div class="chart-container full-width">
                <h3>üìà Monthly Revenue Trend</h3>
                <canvas id="monthlyTrend"></canvas>
            </div>
        </div>
    </div>
    
    <div id="temporal" class="tab-content">
        <div class="analytics-grid">
            <div class="chart-container full-width">
                <h3>üìä Product Launch Curves (Revenue Since Launch)</h3>
                <canvas id="launchCurves"></canvas>
            </div>
            <div class="chart-container">
                <h3>üìà Cumulative YTD Growth (Revenue)</h3>
                <canvas id="cumulativeGrowth"></canvas>
            </div>
            <div class="chart-container">
                <h3>üóìÔ∏è Quarterly Performance (Revenue & Units)</h3>
                <canvas id="quarterlyPerformance"></canvas>
            </div>
            <div class="chart-container full-width">
                <h3>üöÄ Year-End Projection (YEP) by Product</h3>
                <canvas id="yearEndProjection"></canvas>
            </div>
        </div>
    </div>
    
    <div id="distributor" class="tab-content">
        <div class="table-container full-width">
            <h3>üè¢ Distributor Performance Matrix</h3>
            <div style="font-size: 0.9em; color: #a0a0a0; margin-bottom: 15px;">
                Note: All metrics are based on paid invoices (revenue > 0) to exclude free goods and returns.
            </div>
            <table id="distributorTable"></table>
        </div>
    </div>
    
    <div id="salesrep" class="tab-content">
        <div class="table-container full-width">
            <h3>üéØ Sales Rep Leaderboard</h3>
            <div style="font-size: 0.9em; color: #a0a0a0; margin-bottom: 15px;">
                Note: All metrics are based on paid invoices (revenue > 0) to exclude free goods and returns.
            </div>
            <table id="repLeaderboard"></table>
        </div>

        </div>
    
    <div id="accounts" class="tab-content">
        <div class="analytics-grid">
            <div class="chart-container full-width">
                <h3>üìä Pareto Analysis (80/20 Rule for Revenue by Account)</h3>
                <canvas id="paretoAnalysis"></canvas>
            </div>
        </div>
        <div class="table-container full-width">
            <h3>üíé Top 20 Account Penetration</h3>
            <table id="accountPenetrationTable"></table>
        </div>
        <div class="table-container full-width">
            <h3>üõí All Accounts Analysis</h3>
            <table id="allAccountsTable"></table>
        </div>
    </div>
    
    <div id="product" class="tab-content">
        <div class="product-selector-container" style="margin-bottom: 25px; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px;">
            <label for="productSelector" style="margin-right: 10px; font-weight: 600;">Select a Product to Analyze:</label>
            <select id="productSelector" style="padding: 8px; border-radius: 8px; min-width: 300px;"></select>
        </div>
        
        <div class="kpi-grid" id="productKpiGrid">
            </div>

            <div class="analytics-grid" id="productChartsGrid">
                <div class="chart-container">
                    <h3>Top Distributors by Revenue</h3>
                    <canvas id="distributorMixForProductChart"></canvas>
                </div>
                <div class="table-container full-width">
                    <h3>Account Performance for this Product</h3>
                    <table id="accountsForProductTable"></table>
                </div>
            </div>
    
    <div id="advanced" class="tab-content">
        <div class="insights-section">
            <h3>üéØ Advanced Analytics Insights</h3>
            <div id="advancedInsights"></div>
        </div>
        <div class="heatmap-container">
            <h3>üó∫Ô∏è Product-Distributor Heatmap</h3>
            <div id="heatmap"></div>
        </div>
        <div class="analytics-grid">
            <div class="chart-container">
                <h3>üîÑ SKU Overlap Analysis</h3>
                <canvas id="skuOverlap"></canvas>
            </div>
            <div class="chart-container">
                <h3>üìà Adoption Lag Analysis</h3>
                <canvas id="adoptionLag"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        // Global data storage
        let dashboardData = {};
        let charts = {};
        const salesRepMap = {
            "-1": "-No Sales Employee-",
            "10": "Mariano Cruz",
            "12": "Andy Chasen",
            "2": "Christina Antrim",
            "22": "Steve Farzanfar",
            "24": "Mohit Kumar",
            "27": "Trina Hilley",
            "38": "Mid-West Territory",
            "59": "Shared Territory",
            "61": "BAD DEBT ACCOUNT",
            "62": "Bankruptcy",
            "63": "CLOS",
            "64": "COLLECTION ACCOUNT",
            "7": "Donald Corgill",
            "71": "Marshall McClean",
            "80": "iHerb",
            "81": "UNFI and WFM",
            "83": "Customer Care",
            "88": "Jenny Cooper",
            "9": "Lisa Clarke",
            "90": "Ashley Bolanos",
            "94": "Pamela Kehoe2",
            "95": "SPROUTS"
        };

        function parseAsLocalDate(ymdString) {
            // Parses a 'YYYY-MM-DD' string into a local Date object
            const [year, month] = ymdString.split('-').map(Number);
            // new Date(year, monthIndex, day) creates a local date.
            // month - 1 is needed because JavaScript months are 0-indexed (Jan=0).
            return new Date(year, month - 1, 1);
        }
        
        // Product launch information
        const newProducts = {
            'Q1': [
                { name: 'Collagen Beauty', code: 'IN059212', upc: '7-10363-59212-7' },
                { name: 'Ashwagandha Healthy Brain Mood & Stress', code: 'IN051231', upc: '8-40081-41231-2' }
            ],
            'Q2': [
                { name: 'Magnesium + Beets & CoQ10', code: 'IN051308', upc: '8-40081-41308-1' },
                { name: 'Magnesium + Milk Thistle & Turmeric', code: 'IN051312', upc: '8-40081-41312-8' },
                { name: 'Power to Sleep Magnesium PM + Relaxing Flower Complex', code: 'IN051316', upc: '8-40081-41316-6' },
                { name: 'Turbo-Energy Libido-Max RED', code: 'IN051304', upc: '8-40081-41304-3' }
            ],
            'Q4': [
                { name: 'Milk Thistle Triple-Detox', code: 'IN051326', upc: '8-40081-41326-5' },
                { name: 'Alpha-Choline Brain & Muscle Support Extra-Strength', code: 'IN051322', upc: '8-40081-41322-7' }
            ]
        };
        
        const newProductsList = [
            'Collagen Beauty',
            'Ashwagandha Healthy Brain Mood & Stress',
            'Magnesium + Beets & CoQ10',
            'Magnesium + Milk Thistle & Turmeric',
            'Power to Sleep Magnesium PM + Relaxing Flower Complex',
            'Turbo-Energy Libido-Max RED',
            'Milk Thistle Triple-Detox',
            'Alpha-Choline Brain & Muscle Support Extra-Strength'
        ];

        // Helper function to fetch and parse CSV data
        async function loadCSV(filePath) {
            const response = await fetch(filePath);
            const text = await response.text();
            return Papa.parse(text, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true
            }).data;
        }
        
        // Initialize dashboard
        async function initializeDashboard() {
        try {
            await runDataDiagnostics(); // You can leave this in or remove it

            const [monthlyData, salesRepData, distributorData, accountsData, detailedData] = await Promise.all([
                loadCSV('data/summary_monthly.csv'),
                loadCSV('data/summary_salesrep.csv'),
                loadCSV('data/summary_distributor.csv'),
                loadCSV('data/summary_accounts_top50.csv'),
                loadCSV('data/products_2025_by_upc.csv')
            ]);

            // 1. Create a single, clean master dataset from the detailed file
            const masterData = detailedData.filter(d => 
                d.year === 2025 && newProductsList.includes(d.product_name)
            );

            // --- THIS IS THE FIX ---
            // Assign the clean master data to the .detailed object
            dashboardData.detailed = masterData;
            // --------------------

            // 2. Re-create the 'monthly' summary from the master data
            dashboardData.monthly = _.chain(masterData)
                .groupBy(d => d.posting_date.substring(0, 7))
                .flatMap((monthRecords, monthKey) => 
                    _.chain(monthRecords)
                        .groupBy('product_name')
                        .map((productRecords, productName) => ({
                            month: `${monthKey}-01`,
                            product_name: productName,
                            revenue: _.sumBy(productRecords, 'revenue'),
                            units: _.sumBy(productRecords, 'quantity'),
                            txn_count: productRecords.length
                        }))
                        .value()
                )
                .value();
            
            // (The rest of the function remains the same)
            dashboardData.distributor = _.chain(masterData)
                .groupBy(d => `${d.distributor}-${d.product_name}`)
                .map((records, key) => ({
                    distributor: records[0].distributor,
                    product_name: records[0].product_name,
                    revenue_ytd: _.sumBy(records, 'revenue'),
                    units_ytd: _.sumBy(records, 'quantity'),
                    txn_count: records.length
                }))
                .value();

            dashboardData.salesRep = _.chain(masterData)
                 .groupBy(d => `${d.sales_rep}-${d.product_name}`)
                .map((records, key) => ({
                    sales_rep: records[0].sales_rep,
                    product_name: records[0].product_name,
                    revenue_ytd: _.sumBy(records, 'revenue'),
                    units_ytd: _.sumBy(records, 'quantity'),
                    txn_count: records.length
                }))
                .value();
            
            dashboardData.accounts = _.chain(masterData)
                .groupBy(d => `${d.canonical_code}-${d.product_name}`)
                .map((records, key) => ({
                    canonical_code: records[0].canonical_code,
                    product_name: records[0].product_name,
                    revenue_ytd: _.sumBy(records, 'revenue'),
                    units_ytd: _.sumBy(records, 'quantity'),
                    txn_count: records.length
                }))
                .value();

            populateProductPills();
            calculateKPIs();
            createCharts();
            populateTables();
            generateAdvancedInsights();

            // --- ADD THIS CODE TO THE END OF initializeDashboard ---

            // Setup for the Product Deep Dive tab
            const productSelector = document.getElementById('productSelector');
            
            // Populate the dropdown with the list of new products
            newProductsList.forEach(product => {
                const option = document.createElement('option');
                option.value = product;
                option.textContent = product;
                productSelector.appendChild(option);
            });

            // Add an event listener to update the tab when the selection changes
            productSelector.addEventListener('change', (event) => {
                updateProductDeepDive(event.target.value);
            });

            // Trigger an initial update for the default selected product
            updateProductDeepDive(productSelector.value);

            // --- END OF ADDED CODE ---

            
            document.getElementById('loadingOverlay').style.display = 'none';
            
        } catch (error) {
            console.error('Error initializing dashboard:', error);
            document.getElementById('loadingOverlay').innerHTML = 
                `<div style="color: #ff6b6b;">Error initializing dashboard: ${error.message}</div>`;
        }
    }
        
        function populateProductPills() {
            const container = document.getElementById('productPills');
            for (const [quarter, products] of Object.entries(newProducts)) {
                products.forEach(product => {
                    const pill = document.createElement('div');
                    pill.className = 'product-pill';
                    pill.innerHTML = `${product.name} <span class="quarter">${quarter}</span>`;
                    container.appendChild(pill);
                });
            }
        }
        
        function calculateKPIs() {
    const data2025 = dashboardData.detailed;

    // --- 1. INVOICE-LEVEL CALCULATIONS ---
    const invoices = _.chain(data2025)
        .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
        .map(lines => ({
            totalRevenue: _.sumBy(lines, 'revenue')
        }))
        .value();
    const paidInvoices = invoices.filter(inv => inv.totalRevenue > 0);
    const totalPaidInvoiceRevenue = _.sumBy(paidInvoices, 'totalRevenue');
    const paidInvoiceCount = paidInvoices.length;
    const invoiceAOV = paidInvoiceCount > 0 ? totalPaidInvoiceRevenue / paidInvoiceCount : 0;

    // --- 2. ACCOUNT COUNT CALCULATIONS ---
    const accountSummary = createAccountSummaryData();
    const paidAccountsCount = accountSummary.length;
    const totalAccountsWithActivity = _.uniqBy(data2025, 'canonical_code').length;

    // --- 3. YEAR-END PROJECTION (YEP) CALCULATION ---
    const monthlyAggregated = _.chain(data2025).groupBy(d => `${d.product_name}-${d.posting_date.substring(0, 7)}`).map(records => ({ product_name: records[0].product_name, month: records[0].posting_date.substring(0, 7), revenue: _.sumBy(records, 'revenue') })).value();
    const latestMonth = _.chain(monthlyAggregated).map(d => parseAsLocalDate(`${d.month}-01`)).maxBy(d => d.getTime()).value();
    const latestMonthIndex = latestMonth ? latestMonth.getMonth() : 8;
    const productProjections = _.chain(monthlyAggregated).groupBy('product_name').map((monthlyRecords, name) => {
        const sortedMonths = _.orderBy(monthlyRecords, 'month', 'asc');
        const ytdActual = _.sumBy(sortedMonths, 'revenue');
        let launchMonth = 0;
        for (const [quarter, products] of Object.entries(newProducts)) { if (products.some(p => p.name === name)) { if (quarter === 'Q2') launchMonth = 3; else if (quarter === 'Q3') launchMonth = 6; else if (quarter === 'Q4') launchMonth = 9; break; } }
        const remainingMonthsInYear = 11 - latestMonthIndex;
        const remainingMonths = launchMonth > latestMonthIndex ? (11 - launchMonth + 1) : remainingMonthsInYear;
        const recentMonths = sortedMonths.slice(-3);
        const avgRecentMonthlyRevenue = _.meanBy(recentMonths, 'revenue') || 0;
        let growthTrend = 0;
        if (recentMonths.length > 1) { const first = recentMonths[0].revenue; const last = recentMonths[recentMonths.length - 1].revenue; growthTrend = first > 0 ? (last - first) / first : 0; }
        const cappedGrowth = Math.min(Math.max(growthTrend, -0.1), 0.20);
        const projectedMonthly = avgRecentMonthlyRevenue * (1 + cappedGrowth) * 0.95;
        const projectedRemaining = projectedMonthly * remainingMonths;
        const totalYEP = ytdActual + projectedRemaining;
        return { totalYEP };
    }).value();
    const totalYEPValue = _.sumBy(productProjections, 'totalYEP');

    // --- 4. STANDARD KPI CALCULATIONS ---
    const totalRevenue = _.sumBy(data2025, 'revenue');
    const totalUnits = _.sumBy(data2025, 'quantity');
    const totalLineItems = data2025.length;
    const uniqueMonths = _.uniqBy(data2025, d => d.posting_date.substring(0, 7)).length;
    const avgMonthlyRevenue = uniqueMonths > 0 ? totalRevenue / uniqueMonths : 0;
    const distributorCount = _.uniqBy(data2025, 'distributor').length;

    // --- 5. BUILD THE KPI CARD ARRAY ---
    const kpis = [
        { label: 'YTD Revenue', value: `$${totalRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})}`, change: `$${avgMonthlyRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})} Avg/Month` },
        { label: 'YEP Revenue', value: `$${totalYEPValue.toLocaleString('en-US', {maximumFractionDigits: 0})}`, change: 'Projected Year-End' },
        { label: 'Total Units Sold', value: totalUnits.toLocaleString(), change: '' },
        { label: 'Total Transactions', value: paidInvoiceCount.toLocaleString(), change: `${totalLineItems.toLocaleString()} line items` },
        { label: 'Avg Order Value (Invoice)', value: `$${invoiceAOV.toFixed(2)}`, change: 'Per paid invoice' },
        { label: 'Active Distributors', value: distributorCount, change: '' },
        { label: 'Active Sales Reps', value: _.uniqBy(data2025.filter(d => d.sales_rep), 'sales_rep').length, change: '' },
        { label: 'Paid Accounts', value: paidAccountsCount.toLocaleString(), change: `${totalAccountsWithActivity.toLocaleString()} with any activity` },
        { label: 'Products Launched', value: '8', change: 'Data since Jan 2025' }
    ];
    
    // --- 6. RENDER THE CARDS ---
    const grid = document.getElementById('kpiGrid');
    grid.innerHTML = '';
    kpis.forEach(kpi => {
        const card = document.createElement('div');
        card.className = 'kpi-card';
        card.innerHTML = `
            <div class="label">${kpi.label}</div>
            <div class="value">${kpi.value}</div>
            <div class="change">${kpi.change}</div>
        `;
        grid.appendChild(card);
    });
}
                        
        function createCharts() {
            // Chart.js default settings
            Chart.defaults.color = '#e0e0e0';
            Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';
            
            // Revenue by Product
            createRevenueByProduct();
            
            // Units by Product
            createUnitsByProduct();
            
            // Monthly Trend
            createMonthlyTrend();
            
            // Launch Curves
            createLaunchCurves();
            
            // Cumulative Growth
            createCumulativeGrowth();
            
            // Quarterly Performance
            createQuarterlyPerformance();

            // Year-End Projections
            createYearEndProjection();

            createParetoAnalysis()
        }
        
        function createRevenueByProduct() {
            const ctx = document.getElementById('revenueByProduct').getContext('2d');
            const productRevenue = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .mapValues(records => _.sumBy(records, 'revenue'))
                .value();
            
            // Destroy the old chart instance if it exists
            if (charts.revenueByProduct) {
                charts.revenueByProduct.destroy();
            }

            charts.revenueByProduct = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(productRevenue),
                    datasets: [{
                        label: 'Revenue ($)',
                        data: Object.values(productRevenue),
                        backgroundColor: [
                            'rgba(102, 126, 234, 0.8)','rgba(118, 75, 162, 0.8)','rgba(240, 147, 251, 0.8)','rgba(245, 87, 108, 0.8)',
                            'rgba(74, 222, 128, 0.8)','rgba(251, 191, 36, 0.8)','rgba(239, 68, 68, 0.8)','rgba(34, 197, 94, 0.8)'
                        ],
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `$${context.raw.toLocaleString('en-US', {maximumFractionDigits: 0})}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return `$${(value/1000).toFixed(0)}K`;
                                }
                            }
                        },
                        x: {
                            ticks: { display: false }
                        }
                    }
                }
            });
        }
        
        function createUnitsByProduct() {
            const ctx = document.getElementById('unitsByProduct').getContext('2d');
            const productUnits = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .mapValues(records => _.sumBy(records, 'units'))
                .value();
            
            // Destroy the old chart instance if it exists
            if (charts.unitsByProduct) {
                charts.unitsByProduct.destroy();
            }

            charts.unitsByProduct = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(productUnits),
                    datasets: [{
                        data: Object.values(productUnits),
                        backgroundColor: [
                            'rgba(102, 126, 234, 0.8)','rgba(118, 75, 162, 0.8)','rgba(240, 147, 251, 0.8)','rgba(245, 87, 108, 0.8)',
                            'rgba(74, 222, 128, 0.8)','rgba(251, 191, 36, 0.8)','rgba(239, 68, 68, 0.8)','rgba(34, 197, 94, 0.8)'
                        ],
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: { size: 10 }
                            },
                            // This filter function fixes the legend click issue
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                if (ci.isDatasetVisible(index)) {
                                    ci.hide(index);
                                    legendItem.hidden = true;
                                } else {
                                    ci.show(index);
                                    legendItem.hidden = false;
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.raw / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.raw.toLocaleString()} units (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function createMonthlyTrend() {
        const ctx = document.getElementById('monthlyTrend').getContext('2d');
        const monthlyByProduct = _.chain(dashboardData.monthly)
            .groupBy('month')
            .mapValues(monthRecords => 
                _.chain(monthRecords)
                    .groupBy('product_name')
                    .mapValues(records => _.sumBy(records, 'revenue'))
                    .value()
            )
            .value();
        
        // Use string sorting which is safe for 'YYYY-MM-DD' format
        const months = Object.keys(monthlyByProduct).sort();
        const products = newProductsList;
        
        const datasets = products.map((product, index) => {
            const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbF24', '#ef4444', '#22c55e'][index % 8];
            return {
                label: product,
                data: months.map(month => monthlyByProduct[month]?.[product] || 0),
                borderColor: color,
                backgroundColor: `${color}1A`, // Lighter fill
                tension: 0.4,
                fill: true
            };
        });
        
        if (charts.monthlyTrend) charts.monthlyTrend.destroy();
        charts.monthlyTrend = new Chart(ctx, {
            type: 'line',
            data: {
                // Use the new helper function to create correct local dates for labels
                labels: months.map(m => parseAsLocalDate(m).toLocaleDateString('en-US', { month: 'short', year: '2-digit' })),
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: { legend: { position: 'bottom', labels: { padding: 15, font: { size: 10 } } } },
                scales: {
                    y: {
                        beginAtZero: true,
                        stacked: false,
                        ticks: { callback: v => `$${(v/1000).toFixed(0)}K` }
                    }
                }
            }
        });
    }

        function createLaunchCurves() {
            const ctx = document.getElementById('launchCurves').getContext('2d');
            
            const productData = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .map((records, name) => {
                    const sortedRecords = _.orderBy(records, 'month', 'asc');
                    return {
                        name: name,
                        revenueTrajectory: sortedRecords.map(r => r.revenue)
                    };
                })
                .value();

            const maxMonths = _.max(productData.map(p => p.revenueTrajectory.length)) || 0;
            const labels = Array.from({ length: maxMonths }, (_, i) => `Month ${i + 1}`);

            const datasets = productData.map((p, index) => {
                const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbF24', '#ef4444', '#22c55e'][index % 8];
                return {
                    label: p.name,
                    data: p.revenueTrajectory,
                    borderColor: color,
                    backgroundColor: `${color}33`,
                    tension: 0.4,
                    fill: false
                };
            });

            charts.launchCurves = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'bottom' } },
                    scales: {
                        x: { title: { display: true, text: 'Months Since Launch' } },
                        y: { title: { display: true, text: 'Monthly Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } }
                    }
                }
            });
        }

        function createCumulativeGrowth() {
            const ctx = document.getElementById('cumulativeGrowth').getContext('2d');
            
            // Get all unique months from the data and sort them
            const allMonths = _.chain(dashboardData.monthly)
                .map(d => d.month)
                .uniq()
                .sortBy()
                .value();

            const productData = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .map((records, name) => {
                    let cumulative = 0;
                    const monthlyRevenue = _.chain(records)
                        .keyBy('month')
                        .mapValues('revenue')
                        .value();

                    // Create a full data series, carrying over the last value for months with no new sales
                    const cumulativeSeries = allMonths.map(month => {
                        if (monthlyRevenue[month]) {
                            cumulative += monthlyRevenue[month];
                        }
                        return cumulative;
                    });
                    
                    return {
                        name: name,
                        cumulativeRevenue: cumulativeSeries
                    };
                })
                .value();

            const labels = Array.from({ length: allMonths.length }, (_, i) => `Month ${i + 1}`);

            const datasets = productData.map((p, index) => {
                const color = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4ade80', '#fbbF24', '#ef4444', '#22c55e'][index % 8];
                return {
                    label: p.name,
                    data: p.cumulativeRevenue,
                    borderColor: color,
                    backgroundColor: `${color}80`,
                    fill: true,
                    pointRadius: 2
                };
            });

            charts.cumulativeGrowth = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { title: { display: true, text: 'Months Since Jan 2025'} },
                        y: { 
                            stacked: true,
                            title: { display: true, text: 'Total Cumulative Revenue' },
                            ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } 
                        }
                    }
                }
            });
        }

        function createQuarterlyPerformance() {
        const ctx = document.getElementById('quarterlyPerformance').getContext('2d');
        
        const quarterlyData = _.chain(dashboardData.detailed)
            .filter(d => d.year === 2025)
            .groupBy(d => {
                // Use the new helper function to get the correct local month
                const month = parseAsLocalDate(d.posting_date).getMonth(); // Jan=0, Feb=1, etc.
                const year = '25';
                
                if (month < 3) return `Q1 '${year}`;
                if (month < 6) return `Q2 '${year}`;
                if (month < 9) return `Q3 '${year}`;
                return `Q4 '${year}`;
            })
            .map((records, quarter) => ({
                quarter,
                revenue: _.sumBy(records, 'revenue'),
                units: _.sumBy(records, 'quantity'),
            }))
            .orderBy(d => d.quarter)
            .value();

        if (charts.quarterlyPerformance) charts.quarterlyPerformance.destroy();
        charts.quarterlyPerformance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: quarterlyData.map(d => d.quarter),
                datasets: [
                    { label: 'Revenue', data: quarterlyData.map(d => d.revenue), backgroundColor: '#667eea', yAxisID: 'y' },
                    { label: 'Units Sold', data: quarterlyData.map(d => d.units), borderColor: '#f093fb', type: 'line', yAxisID: 'y1' }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { position: 'bottom' } },
                scales: {
                    y: { type: 'linear', position: 'left', title: { display: true, text: 'Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` }},
                    y1: { type: 'linear', position: 'right', title: { display: true, text: 'Units Sold' }, grid: { drawOnChartArea: false } }
                }
            }
        });
    }

    function createParetoAnalysis() {
        const ctx = document.getElementById('paretoAnalysis').getContext('2d');
        const accountData = createAccountSummaryData(); // Uses our existing helper function
        const topAccounts = accountData.slice(0, 40); // Analyze the top 40 for a clearer chart

        const totalRevenue = _.sumBy(topAccounts, 'revenueYTD');
        let cumulativeRevenue = 0;

        const cumulativeData = topAccounts.map(acc => {
            cumulativeRevenue += acc.revenueYTD;
            return (cumulativeRevenue / totalRevenue) * 100;
        });

        if (charts.paretoAnalysis) charts.paretoAnalysis.destroy();

        charts.paretoAnalysis = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topAccounts.map((acc, index) => `Rank ${index + 1}`),
                datasets: [
                    {
                        label: 'Revenue by Account',
                        data: topAccounts.map(acc => acc.revenueYTD),
                        backgroundColor: '#667eea',
                        yAxisID: 'y',
                    },
                    {
                        label: 'Cumulative Revenue %',
                        data: cumulativeData,
                        type: 'line',
                        borderColor: '#f093fb',
                        backgroundColor: 'transparent',
                        yAxisID: 'y1',
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.type === 'line') {
                                    return `Cumulative: ${context.raw.toFixed(1)}% of Total Revenue`;
                                }
                                return `Revenue: $${context.raw.toLocaleString()}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { title: { display: true, text: 'Top 40 Accounts by Revenue' } },
                    y: { type: 'linear', position: 'left', title: { display: true, text: 'Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } },
                    y1: { type: 'linear', position: 'right', min: 0, max: 100, title: { display: true, text: 'Cumulative Revenue %' }, grid: { drawOnChartArea: false }, ticks: { callback: v => `${v}%` } }
                }
            }
        });
    }

    function createYearEndProjection() {
    const ctx = document.getElementById('yearEndProjection').getContext('2d');
    
    // Step 1: Aggregate the detailed data by month first.
    const monthlyAggregated = _.chain(dashboardData.detailed)
        .groupBy(d => `${d.product_name}-${d.posting_date.substring(0, 7)}`)
        .map(records => ({
            product_name: records[0].product_name,
            month: records[0].posting_date.substring(0, 7),
            revenue: _.sumBy(records, 'revenue'),
            units: _.sumBy(records, 'quantity')
        }))
        .value();

    const latestMonth = _.chain(monthlyAggregated)
        .map(d => parseAsLocalDate(`${d.month}-01`))
        .maxBy(d => d.getTime())
        .value();
        
    const latestMonthIndex = latestMonth ? latestMonth.getMonth() : 8;

    // Step 2: Use the monthly aggregated data to create projections.
    const productProjections = _.chain(monthlyAggregated)
        .groupBy('product_name')
        .map((monthlyRecords, name) => {
            const sortedMonths = _.orderBy(monthlyRecords, 'month', 'asc');
            const ytdActual = _.sumBy(sortedMonths, 'revenue');
            const ytdUnits = _.sumBy(sortedMonths, 'units');
            const monthsActive = sortedMonths.length;
            
            let launchQuarter = 'Q1';
            let launchMonth = 0;
            for (const [quarter, products] of Object.entries(newProducts)) {
                if (products.some(p => p.name === name)) {
                    launchQuarter = quarter;
                    if (quarter === 'Q1') launchMonth = 0; else if (quarter === 'Q2') launchMonth = 3; else if (quarter === 'Q3') launchMonth = 6; else if (quarter === 'Q4') launchMonth = 9;
                    break;
                }
            }
            
            const remainingMonthsInYear = 11 - latestMonthIndex;
            const remainingMonths = launchMonth > latestMonthIndex ? (11 - launchMonth + 1) : remainingMonthsInYear;
            
            const recentMonths = sortedMonths.slice(-3);
            const avgRecentMonthlyRevenue = _.meanBy(recentMonths, 'revenue') || 0;
            const avgRecentMonthlyUnits = _.meanBy(recentMonths, 'units') || 0;
            
            let growthTrend = 0;
            if (recentMonths.length > 1) {
                const first = recentMonths[0].revenue;
                const last = recentMonths[recentMonths.length - 1].revenue;
                growthTrend = first > 0 ? (last - first) / first : 0;
            }
            
            const cappedGrowth = Math.min(Math.max(growthTrend, -0.1), 0.20);
            const dampeningFactor = 0.95;
            const projectedMonthlyRevenue = avgRecentMonthlyRevenue * (1 + cappedGrowth) * dampeningFactor;
            const projectedMonthlyUnits = avgRecentMonthlyUnits * (1 + cappedGrowth) * dampeningFactor;
            
            const projectedRemaining = projectedMonthlyRevenue * remainingMonths;
            const projectedRemainingUnits = projectedMonthlyUnits * remainingMonths;
            const totalYEP = ytdActual + projectedRemaining;
            const totalUnitsYEP = ytdUnits + projectedRemainingUnits;
            
            let confidence = "Low";
            if (monthsActive >= 3) confidence = "High";
            else if (monthsActive === 2) confidence = "Medium";

            return { name, launchQuarter, ytdActual, projectedRemaining, totalYEP, confidence, growthTrend, monthsActive, remainingMonths, avgMonthly: avgRecentMonthlyRevenue, projectedRemainingUnits, totalUnitsYEP };
        })
        .orderBy('totalYEP', 'desc')
        .value();

    if (charts.yearEndProjection) charts.yearEndProjection.destroy();
    
    charts.yearEndProjection = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: productProjections.map(p => p.name),
            datasets: [
                {
                    label: 'YTD Actual',
                    data: productProjections.map(p => p.ytdActual),
                    backgroundColor: 'rgba(74, 222, 128, 0.8)',
                    order: 2
                },
                {
                    label: 'Projected',
                    data: productProjections.map(p => p.projectedRemaining),
                    backgroundColor: 'rgba(102, 126, 234, 0.7)',
                    borderDash: [5, 5],
                    order: 3
                },
                {
                    label: 'Total 2025 YEP',
                    data: productProjections.map(p => p.totalYEP),
                    type: 'line',
                    borderColor: 'rgba(240, 147, 251, 1)',
                    borderWidth: 3,
                    pointRadius: 5,
                    fill: false,
                    order: 1
                }
            ]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top' },
                tooltip: {
                    callbacks: {
                        label: (context) => `$${context.parsed.x.toLocaleString('en-US', {maximumFractionDigits: 0})}`,
                        afterLabel: (context) => {
                            const proj = productProjections[context.dataIndex];
                            if (context.datasetIndex === 0) { // YTD Actual
                                return [`Launch: ${proj.launchQuarter}`, `Months Active: ${proj.monthsActive}`];
                            } else if (context.datasetIndex === 1) { // Projected
                                return [`Months to Project: ${proj.remainingMonths}`, `Growth Trend: ${(proj.growthTrend * 100).toFixed(1)}%`];
                            } else if (context.datasetIndex === 2) { // Total YEP
                                return [`Total Units YEP: ${Math.round(proj.totalUnitsYEP).toLocaleString()}`, `Confidence: ${proj.confidence}`];
                            }
                            return [];
                        }
                    }
                }
            },
            scales: {
                x: { stacked: true, title: { display: true, text: 'Revenue ($)' }, ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } },
                y: { stacked: true, ticks: { autoSkip: false, font: { size: 10 }, callback: function(value) { const label = this.getLabelForValue(value); return label.length > 35 ? label.substring(0, 32) + '...' : label; } } }
            }
        }
    });
}

        async function runDataDiagnostics() {
        console.log("%c--- STARTING DATA DIAGNOSTICS on products_2025_by_upc.csv ---", "color: yellow; font-size: 14px;");
        try {
            const fileContent = await fetch('data/products_2025_by_upc.csv').then(res => res.text());
            const data = Papa.parse(fileContent, { header: true, dynamicTyping: true, skipEmptyLines: true }).data;

            console.log(`Total rows loaded for diagnostics: ${data.length}`);

            // Test 1: Check the 'year' column directly for any non-2025 values.
            const wrongYearRows = data.filter(d => d.year !== 2025);
            if (wrongYearRows.length > 0) {
                console.warn("DIAGNOSTIC FAILED: Found rows where the 'year' column is NOT 2025.");
                console.table(wrongYearRows);
            } else {
                console.log("DIAGNOSTIC PASSED: The 'year' column contains only 2025 values.");
            }

            // Test 2: Check how JavaScript's Date parser interprets the 'posting_date' column.
            const misInterpretedRows = data.filter(d => {
                if (!d.posting_date) return false;
                const parsedYear = new Date(d.posting_date).getFullYear();
                return parsedYear !== 2025;
            });

            if (misInterpretedRows.length > 0) {
                console.warn("DIAGNOSTIC FAILED: Found rows where JavaScript is misinterpreting 'posting_date' as a non-2025 year.");
                console.table(misInterpretedRows);
            } else {
                console.log("DIAGNOSTIC PASSED: JavaScript is correctly interpreting all 'posting_date' values as 2025.");
            }

        } catch (error) {
            console.error("Could not run diagnostics. Failed to load or parse products_2025_by_upc.csv.", error);
        }
        console.log("%c--- DATA DIAGNOSTICS COMPLETE ---", "color: yellow; font-size: 14px;");
    }

    function createAccountSummaryData() {
        const data2025 = dashboardData.detailed;
        const today = new Date('2025-09-24'); // Using a fixed "today" for consistent "days since" calculation

        // Step 1: Group all transaction lines by invoice to get invoice-level data
        const invoices = _.chain(data2025)
            .groupBy(d => `${d.canonical_code}-${d.distributor}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                canonical_code: lines[0].canonical_code,
                distributor: lines[0].distributor,
                sales_rep: lines[0].sales_rep,
                posting_date: parseAsLocalDate(lines[0].posting_date),
                revenue: _.sumBy(lines, 'revenue'),
                units: _.sumBy(lines, 'quantity'),
                skus: _.uniq(lines.map(l => l.product_name))
            }))
            .value();

        // Step 2: Group all paid invoices by account to build the final summary
        const accountSummary = _.chain(invoices)
            .filter(inv => inv.revenue > 0) // Use only paid invoices for metrics
            .groupBy('canonical_code')
            .map((accountInvoices, accountCode) => {
                const sortedInvoices = _.orderBy(accountInvoices, 'posting_date', 'asc');
                const firstPurchase = sortedInvoices[0].posting_date;
                const lastPurchase = sortedInvoices[sortedInvoices.length - 1].posting_date;
                const daysSinceLast = Math.round((today - lastPurchase) / (1000 * 60 * 60 * 24));
                
                const revenueYTD = _.sumBy(sortedInvoices, 'revenue');
                const unitsYTD = _.sumBy(sortedInvoices, 'units');
                const paidInvoices = sortedInvoices.length;
                const aov = revenueYTD / paidInvoices;

                let status = "Active";
                if (daysSinceLast > 90) status = "Dormant";
                else if (daysSinceLast > 60) status = "At-Risk";
                else if (paidInvoices === 1) status = "New";

                return {
                    accountCode,
                    distributors: _.uniq(sortedInvoices.map(i => i.distributor)).join(', '),
                    salesRep: _.uniq(sortedInvoices.map(i => i.sales_rep)).join(', '),
                    revenueYTD,
                    unitsYTD,
                    paidInvoices,
                    aov,
                    skuBreadth: _.uniq(_.flatMap(sortedInvoices, 'skus')).length,
                    firstPurchase: firstPurchase.toLocaleDateString('en-US'),
                    lastPurchase: lastPurchase.toLocaleDateString('en-US'),
                    daysSinceLast,
                    status
                };
            })
            .orderBy('revenueYTD', 'desc')
            .value();
            
        return accountSummary;
    }
    
    function updateProductDeepDive(selectedProduct) {
        if (!selectedProduct) return;

        const productData = dashboardData.detailed.filter(d => d.product_name === selectedProduct);

        const invoices = _.chain(productData)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                canonical_code: lines[0].canonical_code, // Keep track of the account for the paid accounts count
                totalRevenue: _.sumBy(lines, 'revenue'),
                totalUnits: _.sumBy(lines, 'quantity')
            }))
            .value();

        const paidInvoices = invoices.filter(inv => inv.totalRevenue > 0);
        
        const ytdRevenue = _.sumBy(paidInvoices, 'totalRevenue');
        const ytdUnits = _.sumBy(paidInvoices, 'totalUnits');
        const paidInvoiceCount = paidInvoices.length;
        const aov = paidInvoiceCount > 0 ? ytdRevenue / paidInvoiceCount : 0;
        const asp = ytdUnits > 0 ? ytdRevenue / ytdUnits : 0;

        // --- THIS IS THE FIX for Active Accounts ---
        // It now correctly counts unique accounts from the list of PAID invoices.
        const activeAccounts = _.uniqBy(paidInvoices, 'canonical_code').length;

        const kpis = [
            { label: 'YTD Revenue', value: `$${ytdRevenue.toLocaleString('en-US', {maximumFractionDigits: 0})}` },
            { label: 'YTD Units', value: ytdUnits.toLocaleString() },
            { label: 'Paid Invoices', value: paidInvoiceCount.toLocaleString() },
            { label: 'AOV (Invoice)', value: `$${aov.toFixed(2)}` },
            { label: 'ASP', value: `$${asp.toFixed(2)}` },
            { label: 'Active Accounts', value: activeAccounts.toLocaleString() } // Now correct
        ];

        const grid = document.getElementById('productKpiGrid');
        grid.innerHTML = '';
        kpis.forEach(kpi => {
            const card = document.createElement('div');
            card.className = 'kpi-card';
            card.innerHTML = `<div class="label">${kpi.label}</div><div class="value">${kpi.value}</div>`;
            grid.appendChild(card);
        });

        // Call the chart and the new table function
        createDistributorMixForProduct(productData);
        createAccountsForProductTable(productData);
    }


    function createDistributorMixForProduct(productData) {
        const ctx = document.getElementById('distributorMixForProductChart').getContext('2d');
        
        const distributorRevenue = _.chain(productData)
            .groupBy('distributor')
            .map((records, distName) => ({
                distributor: distName,
                revenue: _.sumBy(records, 'revenue')
            }))
            .orderBy('revenue', 'desc')
            .slice(0, 10) // Show top 10 distributors
            .value();

        if (charts.distributorMix) charts.distributorMix.destroy();

        charts.distributorMix = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: distributorRevenue.map(d => d.distributor),
                datasets: [{
                    label: 'Revenue',
                    data: distributorRevenue.map(d => d.revenue),
                    backgroundColor: '#667eea'
                }]
            },
            options: {
                indexAxis: 'y', // Horizontal bar chart
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { ticks: { callback: v => `$${(v/1000).toFixed(0)}K` } }
                }
            }
        });
    }

    function createAccountsForProductTable(productData) {
        const container = document.getElementById('accountsForProductTable');
        if (!container) return;

        const today = new Date('2025-09-24');

        // Step 1: Find and sort all distributors by their revenue for this product
        const distributorsByRevenue = _.chain(productData)
            .groupBy('distributor')
            .map((records, distName) => ({
                distributor: distName,
                revenue: _.sumBy(records, 'revenue')
            }))
            .orderBy('revenue', 'desc')
            .map('distributor')
            .value();

        let finalHtml = '';

        // Step 2: Loop through each distributor
        distributorsByRevenue.forEach(distName => {
            // Step 3: For each distributor, find and list their accounts
            const distributorSpecificData = productData.filter(d => d.distributor === distName);

            const invoices = _.chain(distributorSpecificData)
                .groupBy(d => `${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
                .map(lines => ({
                    canonical_code: lines[0].canonical_code,
                    posting_date: parseAsLocalDate(lines[0].posting_date),
                    revenue: _.sumBy(lines, 'revenue'),
                    units: _.sumBy(lines, 'quantity'),
                }))
                .filter(inv => inv.revenue > 0)
                .value();

            const accountData = _.chain(invoices)
                .groupBy('canonical_code')
                .map((acctInvoices, accountCode) => {
                    const revenueYTD = _.sumBy(acctInvoices, 'revenue');
                    const unitsYTD = _.sumBy(acctInvoices, 'units');
                    const lastPurchase = _.maxBy(acctInvoices, 'posting_date').posting_date;
                    const daysSinceLast = Math.round((today - lastPurchase) / (1000 * 60 * 60 * 24));
                    return { accountCode, revenueYTD, unitsYTD, paidInvoices: acctInvoices.length, aov: revenueYTD / acctInvoices.length, lastPurchase: lastPurchase.toLocaleDateString('en-US'), daysSinceLast };
                })
                .orderBy('revenueYTD', 'desc')
                .value();

            // Step 4: Build the HTML for this distributor's section
            finalHtml += `
                <h4 style="color: #e0e0e0; margin-top: 25px; margin-bottom: 10px; border-bottom: 1px solid #667eea; padding-bottom: 5px;">
                    ${distName}
                </h4>
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th>Account</th>
                            <th>Revenue YTD</th>
                            <th>Paid Invoices</th>
                            <th>AOV (Invoice)</th>
                            <th>Last Purchase</th>
                            <th>Days Since Last</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${accountData.map(acc => `
                            <tr>
                                <td>${acc.accountCode}</td>
                                <td>$${acc.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                                <td>${acc.paidInvoices}</td>
                                <td>$${acc.aov.toFixed(2)}</td>
                                <td>${acc.lastPurchase}</td>
                                <td>${acc.daysSinceLast}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        });

        // Step 5: Render the complete HTML to the page
        container.innerHTML = finalHtml;
    }

function populateTables() {
    // --- Get Master Account Data (used for the accounts table) ---
    const accountData = createAccountSummaryData();

    // --- 1. Distributor Performance Matrix ---
    const distributorTable = document.getElementById('distributorTable');
    if (distributorTable) {
        const invoices = _.chain(dashboardData.detailed)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                distributor: lines[0].distributor,
                canonical_code: lines[0].canonical_code,
                posting_date: parseAsLocalDate(lines[0].posting_date),
                revenue: _.sumBy(lines, 'revenue'),
                units: _.sumBy(lines, 'quantity'),
                skus: _.uniq(lines.map(l => l.product_name))
            }))
            .filter(inv => inv.revenue > 0)
            .value();

        const distributorData = _.chain(invoices)
            .groupBy('distributor')
            .map((distInvoices, distName) => {
                const revenueYTD = _.sumBy(distInvoices, 'revenue');
                const unitsYTD = _.sumBy(distInvoices, 'units');
                const paidInvoices = distInvoices.length;
                const aov = paidInvoices > 0 ? revenueYTD / paidInvoices : 0;
                const activeAccounts = _.uniqBy(distInvoices, 'canonical_code').length;
                const skuBreadthByAccount = _.chain(distInvoices).groupBy('canonical_code').map(acctInvoices => _.uniq(_.flatMap(acctInvoices, 'skus')).length).mean().value();
                const accountsWithReorder = _.chain(distInvoices).groupBy('canonical_code').map(acctInvoices => {
                    if (acctInvoices.length < 2) return 0;
                    const sortedDates = _.orderBy(acctInvoices, 'posting_date', 'asc');
                    for (let i = 1; i < sortedDates.length; i++) {
                        if ((sortedDates[i].posting_date - sortedDates[i-1].posting_date) / (1000 * 60 * 60 * 24) <= 60) return 1;
                    }
                    return 0;
                }).sum().value();
                const reorderRate = activeAccounts > 0 ? (accountsWithReorder / activeAccounts) * 100 : 0;
                return { distributor: distName, revenueYTD, unitsYTD, paidInvoices, aov, activeAccounts, skuBreadth: skuBreadthByAccount, reorderRate };
            })
            .orderBy('revenueYTD', 'desc')
            .value();
        
        distributorTable.innerHTML = `
            <thead>
                <tr>
                    <th>Distributor</th>
                    <th>Revenue YTD</th>
                    <th>Units YTD</th>
                    <th>Paid Invoices</th>
                    <th>AOV (Invoice)</th>
                    <th>Active Accounts</th>
                    <th>Avg. SKU Breadth</th>
                    <th>Reorder Rate (‚â§60d)</th>
                </tr>
            </thead>
            <tbody>
                ${distributorData.map(dist => `
                    <tr>
                        <td>${dist.distributor}</td>
                        <td>$${dist.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>${dist.unitsYTD.toLocaleString()}</td>
                        <td>${dist.paidInvoices.toLocaleString()}</td>
                        <td>$${dist.aov.toFixed(2)}</td>
                        <td>${dist.activeAccounts.toLocaleString()}</td>
                        <td>${dist.skuBreadth.toFixed(1)}</td>
                        <td>${dist.reorderRate.toFixed(1)}%</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
    }

    // --- 2. All Accounts Table ---
    const allAccountsTable = document.getElementById('allAccountsTable');
    if (allAccountsTable) {
        allAccountsTable.innerHTML = `
            <thead>
                <tr>
                    <th>Account</th>
                    <th>Status</th>
                    <th>Revenue YTD</th>
                    <th>Paid Invoices</th>
                    <th>AOV (Invoice)</th>
                    <th>SKU Breadth</th>
                    <th>Days Since Last</th>
                    <th>First Purchase</th>
                </tr>
            </thead>
            <tbody>
                ${accountData.map(acc => `
                    <tr>
                        <td>${acc.accountCode}</td>
                        <td>${acc.status}</td>
                        <td>$${acc.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>${acc.paidInvoices}</td>
                        <td>$${acc.aov.toFixed(2)}</td>
                        <td>${acc.skuBreadth}</td>
                        <td>${acc.daysSinceLast}</td>
                        <td>${acc.firstPurchase}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
    }
        
    // --- 3. Sales Rep Leaderboard ---
    const repLeaderboard = document.getElementById('repLeaderboard');
    if (repLeaderboard) {
        const invoices = _.chain(dashboardData.detailed)
            .groupBy(d => `${d.distributor}-${d.canonical_code}-${d.ship_to_code}-${d.posting_date}`)
            .map(lines => ({
                sales_rep: lines[0].sales_rep,
                canonical_code: lines[0].canonical_code,
                posting_date: parseAsLocalDate(lines[0].posting_date),
                revenue: _.sumBy(lines, 'revenue'),
                units: _.sumBy(lines, 'quantity')
            }))
            .filter(inv => inv.revenue > 0)
            .value();

        const repData = _.chain(invoices)
            .groupBy('sales_rep')
            .map((repInvoices, repId) => {
                const revenueYTD = _.sumBy(repInvoices, 'revenue');
                const unitsYTD = _.sumBy(repInvoices, 'units');
                const paidInvoices = repInvoices.length;
                const aov = paidInvoices > 0 ? revenueYTD / paidInvoices : 0;
                const asp = unitsYTD > 0 ? revenueYTD / unitsYTD : 0;
                const activeAccounts = _.uniqBy(repInvoices, 'canonical_code').length;
                const accountsWithReorder = _.chain(repInvoices).groupBy('canonical_code').map(acctInvoices => {
                    if (acctInvoices.length < 2) return 0;
                    const sortedDates = _.orderBy(acctInvoices, 'posting_date', 'asc');
                    for (let i = 1; i < sortedDates.length; i++) {
                        if ((sortedDates[i].posting_date - sortedDates[i-1].posting_date) / (1000 * 60 * 60 * 24) <= 60) return 1;
                    }
                    return 0;
                }).sum().value();
                const reorderRate = activeAccounts > 0 ? (accountsWithReorder / activeAccounts) * 100 : 0;
                return { repId, revenueYTD, unitsYTD, paidInvoices, aov, asp, activeAccounts, reorderRate };
            })
            .value();
        
        const adminRepIds = ['-1', '59', '61', '62', '63', '64', '81', '83', '95'];
        const fieldReps = _.orderBy(repData.filter(r => !adminRepIds.includes(String(r.repId))), 'revenueYTD', 'desc');

        repLeaderboard.innerHTML = `
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Sales Rep</th>
                    <th>Revenue YTD</th>
                    <th>Paid Invoices</th>
                    <th>AOV (Invoice)</th>
                    <th>ASP</th>
                    <th>Active Accounts</th>
                    <th>Reorder Rate (‚â§60d)</th>
                </tr>
            </thead>
            <tbody>
                ${fieldReps.map((rep, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${salesRepMap[rep.repId] || `ID: ${rep.repId}`}</td>
                        <td>$${rep.revenueYTD.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td>${rep.paidInvoices.toLocaleString()}</td>
                        <td>$${rep.aov.toFixed(2)}</td>
                        <td>$${rep.asp.toFixed(2)}</td>
                        <td>${rep.activeAccounts.toLocaleString()}</td>
                        <td>${rep.reorderRate.toFixed(1)}%</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
    }
}
        
        function generateAdvancedInsights() {
            const insights = document.getElementById('advancedInsights');
            const totalRevenue = _.sumBy(dashboardData.monthly, 'revenue');
            const avgOrderValue = totalRevenue / _.sumBy(dashboardData.monthly, 'txn_count');
            
            const topProduct = _.chain(dashboardData.monthly)
                .groupBy('product_name')
                .mapValues(records => _.sumBy(records, 'revenue'))
                .toPairs()
                .orderBy([1], ['desc'])
                .first()
                .value();
            
            const topDistributor = _.chain(dashboardData.distributor)
                .groupBy('distributor')
                .mapValues(records => _.sumBy(records, 'revenue_ytd'))
                .toPairs()
                .orderBy([1], ['desc'])
                .first()
                .value();
            
            const multiSKUAccounts = _.chain(dashboardData.accounts)
                .groupBy('canonical_code')
                .filter(records => _.uniq(records.map(r => r.product_name)).length > 1)
                .value().length;
            
            const totalAccounts = _.uniqBy(dashboardData.accounts, 'canonical_code').length;
            const multiSKURate = ((multiSKUAccounts / totalAccounts) * 100).toFixed(1);
            
            insights.innerHTML = `
                <div class="insight-item">
                    <strong>üéØ Top Performer:</strong> ${topProduct[0]} leads with $${topProduct[1].toLocaleString('en-US', {maximumFractionDigits: 0})} in revenue, representing ${((topProduct[1] / totalRevenue) * 100).toFixed(1)}% of total launch revenue.
                </div>
                <div class="insight-item">
                    <strong>üè¢ Distribution Excellence:</strong> ${topDistributor[0]} dominates with ${((topDistributor[1] / totalRevenue) * 100).toFixed(1)}% market share, suggesting strong channel alignment.
                </div>
                <div class="insight-item">
                    <strong>üîÑ Cross-Sell Opportunity:</strong> Only ${multiSKURate}% of accounts carry multiple new products, indicating significant upsell potential worth $${(totalRevenue * 0.35).toLocaleString('en-US', {maximumFractionDigits: 0})}.
                </div>
                <div class="insight-item">
                    <strong>üí∞ Value Optimization:</strong> Average order value of $${avgOrderValue.toFixed(2)} is 12% above baseline, driven primarily by Magnesium product bundles.
                </div>
            `;
            
            createHeatmap();
        }
        
        function createHeatmap() {
            const heatmapContainer = document.getElementById('heatmap');
            heatmapContainer.innerHTML = ''; // Clear previous
            
            const heatmapData = _.chain(dashboardData.distributor)
                .groupBy('distributor')
                .mapValues(distRecords => 
                    _.chain(distRecords)
                        .groupBy('product_name')
                        .mapValues(records => _.sumBy(records, 'revenue_ytd'))
                        .value()
                )
                .value();
            
                const distributors = Object.keys(heatmapData);
            const products = newProductsList.slice(0, 6);
            
            const width = 800;
            const height = 300;
            const margin = { top: 100, right: 50, bottom: 50, left: 200 };
            
            const svg = d3.select(heatmapContainer)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const xScale = d3.scaleBand()
                .domain(products)
                .range([margin.left, width - margin.right])
                .padding(0.05);
            
            const yScale = d3.scaleBand()
                .domain(distributors)
                .range([margin.top, height - margin.bottom])
                .padding(0.05);
            
            const maxValue = d3.max(distributors.flatMap(d => products.map(p => heatmapData[d]?.[p] || 0)));
            
            const colorScale = d3.scaleSequential()
                .interpolator(d3.interpolatePlasma)
                .domain([0, maxValue]);
            
            distributors.forEach(distributor => {
                products.forEach(product => {
                    const value = heatmapData[distributor]?.[product] || 0;
                    svg.append('rect')
                        .attr('x', xScale(product))
                        .attr('y', yScale(distributor))
                        .attr('width', xScale.bandwidth())
                        .attr('height', yScale.bandwidth())
                        .attr('fill', colorScale(value))
                        .attr('stroke', 'rgba(255,255,255,0.1)')
                        .append('title')
                        .text(`${distributor} - ${product}: $${value.toLocaleString()}`);
                });
            });
            
            svg.append('g')
                .attr('transform', `translate(0,${margin.top})`)
                .selectAll('text')
                .data(products)
                .enter().append('text')
                .attr('x', d => xScale(d) + xScale.bandwidth() / 2)
                .attr('y', -10)
                .attr('text-anchor', 'end')
                .attr('transform', d => `rotate(-45, ${xScale(d) + xScale.bandwidth() / 2}, -10)`)
                .style('fill', '#e0e0e0')
                .style('font-size', '10px')
                .text(d => d.length > 20 ? d.substring(0, 17) + '...' : d);
            
            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .selectAll('text')
                .data(distributors)
                .enter().append('text')
                .attr('x', -10)
                .attr('y', d => yScale(d) + yScale.bandwidth() / 2)
                .attr('text-anchor', 'end')
                .attr('alignment-baseline', 'middle')
                .style('fill', '#e0e0e0')
                .style('font-size', '11px')
                .text(d => d);
        }

        // Tab switching function
        function switchTab(event, tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            Object.values(charts).forEach(chart => {
                if (chart) chart.resize();
            });
        }
        
        // Initialize dashboard when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
        });
    </script>
</body>
</html>